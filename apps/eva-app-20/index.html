<!DOCTYPE html>
<html lang="en"><head><script>(function(firebaseConfig, initialAuthToken, appId) {
        window.__firebase_config = firebaseConfig;
        window.__initial_auth_token = initialAuthToken;
        window.__app_id = appId;
            })("\n{\n  \"apiKey\": \"AIzaSyCqyCcs2R2e7AegGjvFAwG98wlamtbHvZY\",\n  \"authDomain\": \"bard-frontend.firebaseapp.com\",\n  \"projectId\": \"bard-frontend\",\n  \"storageBucket\": \"bard-frontend.firebasestorage.app\",\n  \"messagingSenderId\": \"175205271074\",\n  \"appId\": \"1:175205271074:web:2b7bd4d34d33bf38e6ec7b\"\n}\n","eyJhbGciOiJSUzI1NiIsImtpZCI6IjY0ZjA3ZDcxOTc5ZjQzODI3MjJhOGRmMzQwNzUzY2UwZmVkOThjYTgiLCJ0eXAiOiJKV1QifQ.eyJzdWIiOiJmaXJlYmFzZS1hZG1pbnNkay1mYnN2Y0BiYXJkLWZyb250ZW5kLmlhbS5nc2VydmljZWFjY291bnQuY29tIiwiYXVkIjoiaHR0cHM6Ly9pZGVudGl0eXRvb2xraXQuZ29vZ2xlYXBpcy5jb20vZ29vZ2xlLmlkZW50aXR5LmlkZW50aXR5dG9vbGtpdC52MS5JZGVudGl0eVRvb2xraXQiLCJ1aWQiOiIxMjc1ODM2MTU4NDMzNTIyMzc4MCIsImlzcyI6ImZpcmViYXNlLWFkbWluc2RrLWZic3ZjQGJhcmQtZnJvbnRlbmQuaWFtLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJjbGFpbXMiOnsiYXBwSWQiOiIwZDY5OTk5OWE0NWYtaW5kZXguaHRtbC0yNDgifSwiZXhwIjoxNzcxNTY2Nzc5LCJpYXQiOjE3NzE1NjMxNzksImFsZyI6IlJTMjU2In0.NfndQnYW2acH6zd2mfhOXVq0AbteEUMS2Wb4ePAsg8BSHBD5VrC6m3bgRqV2VXDX0i1LEbK8mnxW9RsJ40QC34hE1Sd_ecUOKLrh3VWantQT2-k2_IegucD5HKNNXMX0RJNupVJpWQKqChuSclEOuABrBr2mioq_4mK4ghNLpktx6m8aMAwvUAtS8GY-26dbV1leyQ5WwNBvH0NwuSFxOJYraCKVGm5G0adQd5Pu1QsaWzuUPG651CPQuUNo3b-Mddi6Fr5898gK17mPmlwNej0Kj-uLVxP5bTz5mBUKlDL4Hu-VJrfx8ZWmz18IjO8VFExqr9ZECu8SXr3V_o74kw","0d699999a45f-index.html-248")</script><script>(function(){'use strict';var h=typeof Object.defineProperties=="function"?Object.defineProperty:function(a,b,d){if(a==Array.prototype||a==Object.prototype)return a;a[b]=d.value;return a};function l(a){a=["object"==typeof globalThis&&globalThis,a,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var b=0;b<a.length;++b){var d=a[b];if(d&&d.Math==Math)return d}throw Error("Cannot find global object");}var n=l(this);
function p(a,b){if(b)a:{var d=n;a=a.split(".");for(var c=0;c<a.length-1;c++){var e=a[c];if(!(e in d))break a;d=d[e]}a=a[a.length-1];c=d[a];b=b(c);b!=c&&b!=null&&h(d,a,{configurable:!0,writable:!0,value:b})}}function r(a){function b(c){return a.next(c)}function d(c){return a.throw(c)}return new Promise(function(c,e){function f(g){g.done?c(g.value):Promise.resolve(g.value).then(b,d).then(f,e)}f(a.next())})}function t(a){return r(a())}
p("Object.values",function(a){return a?a:function(b){var d=[],c;for(c in b)Object.prototype.hasOwnProperty.call(b,c)&&d.push(b[c]);return d}});p("Array.prototype.includes",function(a){return a?a:function(b,d){var c=this;c instanceof String&&(c=String(c));var e=c.length;d=d||0;for(d<0&&(d=Math.max(d+e,0));d<e;d++){var f=c[d];if(f===b||Object.is(f,b))return!0}return!1}});/*

 MIT License

 Copyright (c) 2017-2023 W.Y.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

*/
function u(a,b){const d=a.style;b.backgroundColor&&(d.backgroundColor=b.backgroundColor);b.width&&(d.width=`${b.width}px`);b.height&&(d.height=`${b.height}px`);const c=b.style;c!=null&&Object.keys(c).forEach(e=>{d[e]=c[e]})};var v=(()=>{let a=0;return()=>{a+=1;return`u${`0000${(Math.random()*1679616<<0).toString(36)}`.slice(-4)}${a}`}})();function w(a){const b=[];for(let d=0,c=a.length;d<c;d++)b.push(a[d]);return b}let x=null;function y(a={}){return x?x:a.l?x=a.l:x=w(window.getComputedStyle(document.documentElement))}function z(a,b){return(a=(a.ownerDocument.defaultView||window).getComputedStyle(a).getPropertyValue(b))?parseFloat(a.replace("px","")):0}
function A(a,b={}){var d;if(!(d=b.width)){d=z(a,"border-left-width");var c=z(a,"border-right-width");d=a.clientWidth+d+c}(b=b.height)||(b=z(a,"border-top-width"),c=z(a,"border-bottom-width"),b=a.clientHeight+b+c);return{width:d,height:b}}function B(a){return new Promise((b,d)=>{const c=new Image;c.onload=()=>{c.decode().then(()=>{requestAnimationFrame(()=>b(c))})};c.onerror=d;c.crossOrigin="anonymous";c.decoding="async";c.src=a})}
function C(a){return t(function*(){return Promise.resolve().then(()=>(new XMLSerializer).serializeToString(a)).then(encodeURIComponent).then(b=>`data:image/svg+xml;charset=utf-8,${b}`)})}
function D(a,b,d){return t(function*(){const c=document.createElementNS("http://www.w3.org/2000/svg","svg"),e=document.createElementNS("http://www.w3.org/2000/svg","foreignObject");c.setAttribute("width",`${b}`);c.setAttribute("height",`${d}`);c.setAttribute("viewBox",`0 0 ${b} ${d}`);e.setAttribute("width","100%");e.setAttribute("height","100%");e.setAttribute("x","0");e.setAttribute("y","0");e.setAttribute("externalResourcesRequired","true");c.appendChild(e);e.appendChild(a);return C(c)})}
var E=(a,b)=>{if(a instanceof b)return!0;a=Object.getPrototypeOf(a);return a===null?!1:a.constructor.name===b.name||E(a,b)};function F(a,b){return y(b).map(d=>{const c=a.getPropertyValue(d),e=a.getPropertyPriority(d);return`${d}: ${c}${e?" !important":""};`}).join(" ")}
function G(a,b,d,c){a=window.getComputedStyle(a,d);var e=a.getPropertyValue("content");if(e!==""&&e!=="none"){var f=v();try{b.className=`${b.className} ${f}`}catch(k){return}e=document.createElement("style");var g=e.appendChild;d=`.${f}:${d}`;a.cssText?(c=a.getPropertyValue("content"),c=`${a.cssText} content: '${c.replace(/'|"/g,"")}';`):c=F(a,c);g.call(e,document.createTextNode(`${d}{${c}}`));b.appendChild(e)}};function H(a){return a.search(/^(data:)/)!==-1}function I(a,b,d){return t(function*(){const c=yield fetch(a,b);if(c.status===404)throw Error(`Resource "${c.url}" not found`);const e=yield c.blob();return new Promise((f,g)=>{const k=new FileReader;k.onerror=g;k.onloadend=()=>{try{f(d({o:c,result:k.result}))}catch(m){g(m)}};k.readAsDataURL(e)})})}const J={};function K(a,b,d){let c=a.replace(/\?.*/,"");d&&(c=a);/ttf|otf|eot|woff2?/i.test(c)&&(c=c.replace(/.*\//,""));return b?`[${b}]${c}`:c}
function L(a,b,d){return t(function*(){const c=K(a,b,d.C);if(J[c]!=null)return J[c];d.u&&(a+=(/\?/.test(a)?"&":"?")+(new Date).getTime());let e;try{const f=yield I(a,d.i,({o:g,result:k})=>{b||(b=g.headers.get("Content-Type")||"");return k.split(/,/)[1]});e=`data:${b};base64,${f}`}catch(f){e=d.B||""}return J[c]=e})};const M={P:"application/font-woff",R:"application/font-woff",N:"application/font-truetype",v:"application/vnd.ms-fontobject",H:"image/png",F:"image/jpeg",D:"image/jpeg",A:"image/gif",M:"image/tiff",L:"image/svg+xml",O:"image/webp"};function N(a){return(a=/\.([^./]*?)$/g.exec(a))?a[1]:""};function O(a){return t(function*(){const b=a.toDataURL();return b==="data:,"?a.cloneNode(!1):B(b)})}function aa(a,b){return t(function*(){if(a.currentSrc){var d=document.createElement("canvas");const c=d.getContext("2d");d.width=a.clientWidth;d.height=a.clientHeight;c==null||c.drawImage(a,0,0,d.width,d.height);d=d.toDataURL();return B(d)}d=a.poster;d=yield L(d,M[N(d).toLowerCase()]||"",b);return B(d)})}
function ba(a,b){return t(function*(){try{let d;if(a==null?0:(d=a.contentDocument)==null?0:d.body)return yield P(a.contentDocument.body,b,!0)}catch(d){}return a.cloneNode(!1)})}function ca(a,b){return t(function*(){return E(a,HTMLCanvasElement)?O(a):E(a,HTMLVideoElement)?aa(a,b):E(a,HTMLIFrameElement)?ba(a,b):a.cloneNode(a.tagName!=null&&a.tagName.toUpperCase()==="SVG")})}
function da(a,b,d){return t(function*(){if(b.tagName!=null&&b.tagName.toUpperCase()==="SVG")return b;let c=[];if(a.tagName!=null&&a.tagName.toUpperCase()==="SLOT"&&a.assignedNodes)c=w(a.assignedNodes());else{let e;if(E(a,HTMLIFrameElement)&&((e=a.contentDocument)==null?0:e.body))c=w(a.contentDocument.body.childNodes);else{let f;c=w(((f=a.shadowRoot)!=null?f:a).childNodes)}}if(c.length===0||E(a,HTMLVideoElement))return b;yield c.reduce((e,f)=>e.then(()=>P(f,d)).then(g=>{g&&b.appendChild(g)}),Promise.resolve());
return b})}function ea(a,b,d){const c=b.style;if(c){var e=window.getComputedStyle(a);e.cssText?(c.cssText=e.cssText,c.transformOrigin=e.transformOrigin):y(d).forEach(f=>{let g=e.getPropertyValue(f);f==="font-size"&&g.endsWith("px")&&(g=`${Math.floor(parseFloat(g.substring(0,g.length-2)))-.1}px`);E(a,HTMLIFrameElement)&&f==="display"&&g==="inline"&&(g="block");f==="d"&&b.getAttribute("d")&&(g=`path(${b.getAttribute("d")})`);c.setProperty(f,g,e.getPropertyPriority(f))})}}
function fa(a,b){E(a,HTMLSelectElement)&&(b=Array.from(b.children).find(d=>a.value===d.getAttribute("value")))&&b.setAttribute("selected","")}
function ha(a,b){return t(function*(){var d=a.querySelectorAll?a.querySelectorAll("use"):[];if(d.length===0)return a;var c={};for(var e=0;e<d.length;e++){var f=d[e].getAttribute("xlink:href");if(f){const g=document.querySelector(f);a.querySelector(f)||!g||c[f]||(c[f]=yield P(g,b,!0))}}d=Object.values(c);if(d.length){c=document.createElementNS("http://www.w3.org/1999/xhtml","svg");c.setAttribute("xmlns","http://www.w3.org/1999/xhtml");c.style.position="absolute";c.style.width="0";c.style.height="0";
c.style.overflow="hidden";c.style.display="none";e=document.createElementNS("http://www.w3.org/1999/xhtml","defs");c.appendChild(e);for(f=0;f<d.length;f++)e.appendChild(d[f]);a.appendChild(c)}return a})}
function P(a,b,d){return t(function*(){return d||!b.filter||b.filter(a)?Promise.resolve(a).then(c=>ca(c,b)).then(c=>da(a,c,b)).then(c=>{E(c,Element)&&(ea(a,c,b),G(a,c,":before",b),G(a,c,":after",b),E(a,HTMLTextAreaElement)&&(c.textContent=a.value),E(a,HTMLInputElement)&&c.setAttribute("value",a.value),fa(a,c));return c}).then(c=>ha(c,b)):null})};const Q=/url\((['"]?)([^'"]+?)\1\)/g,ia=/url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g,ja=/src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;function ka(a){const b=[];a.replace(Q,(d,c,e)=>{b.push(e);return d});return b.filter(d=>!H(d))}
function la(a,b,d,c){return t(function*(){try{const e=d?(new URL(b,d||void 0)).toString():b;let f;f=yield L(e,M[N(b).toLowerCase()]||"",c);return a.replace(new RegExp(`(url\\(['"]?)(${b.replace(/([.*+?^${}()|\[\]\/\\])/g,"\\$1")})(['"]?\\))`,"g"),`$1${f}$3`)}catch(e){}return a})}function ma(a,{I:b}){return b?a.replace(ja,d=>{for(;;){const [c,,e]=ia.exec(d)||[],f=c,g=e;if(!g)return"";if(g===b)return`src: ${f};`}}):a}
function R(a,b,d){return t(function*(){if(a.search(Q)===-1)return a;const c=ma(a,d);return ka(c).reduce((e,f)=>e.then(g=>la(g,f,b,d)),Promise.resolve(c))})};function S(a,b,d){return t(function*(){var c;const e=(c=b.style)==null?void 0:c.getPropertyValue(a);return e?(c=yield R(e,null,d),b.style.setProperty(a,c,b.style.getPropertyPriority(a)),!0):!1})}function na(a,b){return t(function*(){(yield S("background",a,b))||(yield S("background-image",a,b));(yield S("mask",a,b))||(yield S("-webkit-mask",a,b))||(yield S("mask-image",a,b))||(yield S("-webkit-mask-image",a,b))})}
function oa(a,b){return t(function*(){const d=E(a,HTMLImageElement);if(d&&!H(a.src)||E(a,SVGImageElement)&&!H(a.href.baseVal)){var c=d?a.src:a.href.baseVal,e=yield L(c,M[N(c).toLowerCase()]||"",b);yield new Promise((f,g)=>{a.onload=f;a.onerror=b.m?(...k)=>{try{f(b.m(...k))}catch(m){g(m)}}:g;a.decode&&(a.decode=f);a.loading==="lazy"&&(a.loading="eager");d?(a.srcset="",a.src=e):a.href.baseVal=e})}})}
function pa(a,b){return t(function*(){const d=w(a.childNodes).map(c=>T(c,b));yield Promise.all(d).then(()=>a)})}function T(a,b){return t(function*(){E(a,Element)&&(yield na(a,b),yield oa(a,b),yield pa(a,b))})};const U={};function V(a){return t(function*(){var b=U[a];if(b!=null)return b;b=yield(yield fetch(a)).text();b={url:a,cssText:b};return U[a]=b})}function W(a,b){return t(function*(){let d=a.cssText;const c=/url\(["']?([^"')]+)["']?\)/g,e=(d.match(/url\([^)]+\)/g)||[]).map(f=>t(function*(){let g=f.replace(c,"$1");g.startsWith("https://")||(g=(new URL(g,a.url)).href);return I(g,b.i,({result:k})=>{d=d.replace(f,`url(${k})`);return[f,k]})}));return Promise.all(e).then(()=>d)})}
function X(a){if(a==null)return[];const b=[];a=a.replace(/(\/\*[\s\S]*?\*\/)/gi,"");for(var d=RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})","gi");;){var c=d.exec(a);if(c===null)break;b.push(c[0])}a=a.replace(d,"");d=/@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;for(c=RegExp("((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})","gi");;){let e=d.exec(a);if(e===null)if(e=c.exec(a),e===null)break;else d.lastIndex=c.lastIndex;else c.lastIndex=
d.lastIndex;b.push(e[0])}return b}
function qa(a,b){return t(function*(){const d=[],c=[];a.forEach(e=>{if("cssRules"in e)try{w(e.cssRules||[]).forEach((f,g)=>{if(f.type===CSSRule.IMPORT_RULE){let k=g+1;f=V(f.href).then(m=>W(m,b)).then(m=>X(m).forEach(q=>{try{e.insertRule(q,q.startsWith("@import")?k+=1:e.cssRules.length)}catch(Da){}})).catch(()=>{});c.push(f)}})}catch(f){const g=a.find(k=>k.href==null)||document.styleSheets[0];e.href!=null&&c.push(V(e.href).then(k=>W(k,b)).then(k=>X(k).forEach(m=>{g.insertRule(m,g.cssRules.length)})).catch(()=>
{}))}});return Promise.all(c).then(()=>{a.forEach(e=>{if("cssRules"in e)try{w(e.cssRules||[]).forEach(f=>{d.push(f)})}catch(f){}});return d})})}function ra(a){return a.filter(b=>b.type===CSSRule.FONT_FACE_RULE).filter(b=>b.style.getPropertyValue("src").search(Q)!==-1)}function sa(a,b){return t(function*(){if(a.ownerDocument==null)throw Error("Provided element is not within a Document");var d=w(a.ownerDocument.styleSheets);d=yield qa(d,b);return ra(d)})}
function ta(a){function b(c){(c.style.fontFamily||getComputedStyle(c).fontFamily).split(",").forEach(e=>{d.add(e.trim().replace(/["']/g,""))});Array.from(c.children).forEach(e=>{e instanceof HTMLElement&&b(e)})}const d=new Set;b(a);return d}function ua(a,b){return t(function*(){const d=yield sa(a,b),c=ta(a);return(yield Promise.all(d.filter(e=>c.has(e.style.fontFamily.trim().replace(/["']/g,""))).map(e=>R(e.cssText,e.parentStyleSheet?e.parentStyleSheet.href:null,b)))).join("\n")})}
function va(a,b){return t(function*(){const d=b.j!=null?b.j:b.K?null:yield ua(a,b);if(d){const c=document.createElement("style");c.appendChild(document.createTextNode(d));a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)}})};function wa(a,b={}){return t(function*(){const {width:d,height:c}=A(a,b),e=yield P(a,b,!0);yield va(e,b);yield T(e,b);u(e,b);return yield D(e,d,c)})}
function xa(a,b={}){return t(function*(){const {width:d,height:c}=A(a,b);var e=yield wa(a,b);e=yield B(e);const f=document.createElement("canvas"),g=f.getContext("2d"),k=b.G||window.devicePixelRatio||1,m=b.h||d,q=b.g||c;f.width=m*k;f.height=q*k;!b.J&&(f.width>16384||f.height>16384)&&(f.width>16384&&f.height>16384?f.width>f.height?(f.height*=16384/f.width,f.width=16384):(f.width*=16384/f.height,f.height=16384):f.width>16384?(f.height*=16384/f.width,f.width=16384):(f.width*=16384/f.height,f.height=
16384));f.style.width=`${m}`;f.style.height=`${q}`;b.backgroundColor&&(g.fillStyle=b.backgroundColor,g.fillRect(0,0,f.width,f.height));g.drawImage(e,0,0,f.width,f.height);return f})}function ya(a,b={}){return t(function*(){return(yield xa(a,b)).toDataURL()})};const za=["gemini.google.com","corp.google.com","proxy.googlers.com"];function Y(){return document.body.querySelectorAll('[class*="animate"]').length>0}function Z(a){return t(function*(){try{return yield ya(a,{h:a.offsetWidth,g:a.offsetHeight})}catch(d){var b=a.offsetHeight;const c=document.createElement("canvas");c.width=a.offsetWidth;c.height=b;return c.toDataURL("image/png")}})}
function Aa(){return t(function*(){const a=document.body.offsetWidth,b=document.body.offsetHeight,d=document.body.cloneNode(!0);d.querySelectorAll('[class*="animate"]').forEach(c=>{c.classList.remove(...Array.from(c.classList).filter(e=>e.startsWith("animate")))});d.style.width=`${a}px`;d.style.height=`${b}px`;return d})}
function Ba(a){return t(function*(){let b=document.body;if(Y()){var d=yield Aa();b=d;document.body.appendChild(d)}d=yield Z(b);Y()&&document.body.removeChild(b);window.parent.postMessage({type:"SEND_SCREENSHOT",image:d,topOffset:document.documentElement.scrollTop},a.origin)})}function Ca(a){return t(function*(){const b={type:"SEND_SCREENSHOT_FOR_DATA_VISUALIZATION",image:yield Z(document.body),topOffset:0};window.parent.postMessage(b,a.origin)})}
window.addEventListener("message",a=>t(function*(){if(za.some(d=>a.origin.includes(d))){var b=a.data;b&&(b.type==="MAKE_SCREENSHOT"&&(yield Ba(a)),b.type==="MAKE_SCREENSHOT_FOR_DATA_VISUALIZATION"&&(yield Ca(a)))}}));
})();</script><script>(function() {
  // Ensure this script is executed only once
  if (window.firebaseAuthBridgeScriptLoaded) {
    return;
  }
  window.firebaseAuthBridgeScriptLoaded = true;

  let nextTokenPromiseId = 0;

  // Stores { resolve, reject } for ongoing token requests
  const pendingTokenPromises = {};

  // Listen for messages from the Host Application
  window.addEventListener('message', function(event) {

    const messageData = event.data;

  if (messageData && messageData.type === 'RESOLVE_NEW_FIREBASE_TOKEN') {
      const { success, token, error, promiseId } = messageData ?? {};
      if (pendingTokenPromises[promiseId]) {
        if (success) {
          pendingTokenPromises[promiseId].resolve(token);
        } else {
          pendingTokenPromises[promiseId].reject(new Error(error || 'Token refresh failed from host.'));
        }
        delete pendingTokenPromises[promiseId];
      }
    }
  });

  // Expose a function for the Generated App to request a new Firebase token
  window.requestNewFirebaseToken = function() {
    const currentPromiseId = nextTokenPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingTokenPromises[currentPromiseId] = { resolve, reject };
    });
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({
        type: 'REQUEST_NEW_FIREBASE_TOKEN',
        promiseId: currentPromiseId
      }, '*');
    } else {
      pendingTokenPromises[currentPromiseId].reject(new Error('No parent window to request token from.'));
      delete pendingTokenPromises[currentPromiseId];
    }
    return promise;
  };
})();</script><script>
let realOriginalGetUserMedia = null;
if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
  realOriginalGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
}

(function() {
  if (navigator.mediaDevices && navigator.mediaDevices.__proto__) {
    try {
      Object.defineProperty(navigator.mediaDevices.__proto__, 'getUserMedia', {
        get: function() {
          return undefined; // Or throw an error
        },
        configurable: false
      });
    } catch (error) {
      console.error("Error defining prototype getter:", error);
    }
  }
})();

(function() {
  const pendingMediaResolvers = {};
  let nextMediaPromiseId = 0;

  function requestMediaPermissions(constraints) {
    const mediaPromiseId = nextMediaPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingMediaResolvers[mediaPromiseId] = (granted) => {
        delete pendingMediaResolvers[mediaPromiseId];
        resolve(granted);
      };
    });

    window.parent.postMessage({
      type: 'requestMediaPermission',
      constraints: constraints,
      promiseId: mediaPromiseId,
    }, '*');

    return promise;
  }

  let originalGetUserMedia = realOriginalGetUserMedia;

  function interceptGetUserMedia() {
    if (navigator.mediaDevices) {
      Object.defineProperty(navigator.mediaDevices, 'getUserMedia', {
        value: function(constraints) {
          return requestMediaPermissions(constraints).then((granted) => {
            if (granted) {
              if (originalGetUserMedia) {
                return originalGetUserMedia(constraints);
              } else {
                throw new Error("Original getUserMedia not available.");
              }
            } else {
              throw new DOMException('Permission denied', 'NotAllowedError');
            }
          });
        },
        writable: false,
        configurable: false
      });
    }
  }

  interceptGetUserMedia();

  const observer = new MutationObserver(function(mutationsList, observer) {
    for (const mutation of mutationsList) {
      if (mutation.type === 'reconfigured' && mutation.name === 'getUserMedia' && mutation.object === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'attributes' && mutation.attributeName === 'getUserMedia' && mutation.target === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'childList' && mutation.addedNodes) {
        mutation.addedNodes.forEach(node => {
          if (node === navigator.mediaDevices) {
            interceptGetUserMedia();
          }
        });
      }
    }
  });

  function interceptSpeechRecognition() {
    if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
      return;
    }

    const OriginalSpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

    const SpeechRecognitionWrapper = function(...args) {
      const recognizer = new OriginalSpeechRecognition(...args);
      const originalStart = recognizer.start.bind(recognizer);

      recognizer.start = function() {
        requestMediaPermissions({ audio: true }).then(granted => {
          if (granted) {
            originalStart();
          } else {
            const errorEvent = new SpeechRecognitionErrorEvent('error');
            errorEvent.error = 'not-allowed'; // This is the standard error for permission denial.
            recognizer.dispatchEvent(errorEvent);
          }
        });
      };

      return recognizer;
    };

    SpeechRecognitionWrapper.prototype = OriginalSpeechRecognition.prototype;
    SpeechRecognitionWrapper.prototype.constructor = SpeechRecognitionWrapper;

    if (window.SpeechRecognition) {
      window.SpeechRecognition = SpeechRecognitionWrapper;
    }
    if (window.webkitSpeechRecognition) {
      window.webkitSpeechRecognition = SpeechRecognitionWrapper;
    }
  }

  interceptSpeechRecognition();

  window.addEventListener('message', function(event) {
    if (event.data) {
      if (event.data.type === 'resolveMediaPermission') {
        const { promiseId, granted } = event.data;
        if (pendingMediaResolvers[promiseId]) {
          pendingMediaResolvers[promiseId](granted);
        }
      }
    }
  });

})();</script><script>((function(modelInformation) {
  const originalFetch = window.fetch;
  // TODO: b/421908508 - Move these out of the script and match all generative AI model calls.
  let googleLlmBaseApiUrls = [
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':streamGenerateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageEditModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageTransformModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.ttsModelName + ':generateContent',
  ];
  modelInformation.deprecatedTextModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':streamGenerateContent',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':generateContent',
    );
  });
  modelInformation.deprecatedImageModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':predict',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':predictLongRunning',
    );
  });

  const pendingFetchResolvers = {};
  let nextPromiseId = 0;

  function handleStringInput(input, optionsArgument) {
    const actualUrl = input;
    const fetchCallArgs = [actualUrl, optionsArgument];
    const effectiveOptions = optionsArgument || {};
    const bodyForApiKeyCheck = effectiveOptions.body;
    const bodyForPostMessage = effectiveOptions.body;
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  function handleRequestInput(input, optionsArgument) {
    const actualUrl = input.url;
    const fetchCallArgs = [input, optionsArgument];
    const effectiveOptions = { method: input.method, headers: new Headers(input.headers) };
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (optionsArgument) {
      if (optionsArgument.method) effectiveOptions.method = optionsArgument.method;
      if (optionsArgument.headers) effectiveOptions.headers = new Headers(optionsArgument.headers);
      if ('body' in optionsArgument) {
        bodyForApiKeyCheck = optionsArgument.body;
        bodyForPostMessage = optionsArgument.body;
      } else {
        bodyForApiKeyCheck = undefined;
        bodyForPostMessage = input.body;
      }
    } else {
      bodyForApiKeyCheck = undefined;
      bodyForPostMessage = input.body;
    }
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  window.fetch = function(input, optionsArgument) {
    let actualUrl;
    let fetchCallArgs;
    let effectiveOptions = {};
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (typeof input === 'string') {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleStringInput(input, optionsArgument));
    } else if (input instanceof Request) {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleRequestInput(input, optionsArgument));
    } else {
      return originalFetch.apply(window, [input, optionsArgument]);
    }

    effectiveOptions.method = effectiveOptions.method || 'GET';
    if (!effectiveOptions.headers) {
      effectiveOptions.headers = new Headers();
    }


    if (typeof actualUrl === 'string' && googleLlmBaseApiUrls.some((url) => actualUrl.startsWith(url))) {
      let apiKeyIsNull = true;

      const regex = new RegExp("models/([^:]+)");
      const modelNameMatch = actualUrl.match(regex);
      const modelName = modelNameMatch ? modelNameMatch[1] : 'unspecified';


      try {
        const urlObject = new URL(actualUrl);  // Use URL object for robust parsing
        const apiKeyParam = urlObject.searchParams.get('key');
        if (apiKeyParam) {
          apiKeyIsNull = false;
        }
      } catch (e) {
        // Continue checks even if URL parsing fails
      }

      if (apiKeyIsNull && effectiveOptions.headers) {
        const h = new Headers(effectiveOptions.headers);
        const apiKeyHeaderValue = h.get('X-API-Key') || h.get('x-api-key');
        if (apiKeyHeaderValue) {
          apiKeyIsNull = false;
          return originalFetch.apply(window, fetchCallArgs);
        }
      }

      if (apiKeyIsNull && effectiveOptions.method && ['POST', 'PUT', 'PATCH'].includes(effectiveOptions.method.toUpperCase()) && typeof bodyForApiKeyCheck === 'string') {
        try {
          const bodyData = JSON.parse(bodyForApiKeyCheck);
          if (bodyData && bodyData.apiKey) {
            apiKeyIsNull = false;
            return originalFetch.apply(window, fetchCallArgs);
          }
        } catch (e) {
          // Ignore JSON parsing errors
        }
      }

      if(apiKeyIsNull) {
        const promiseId = nextPromiseId++;
        const promise = new Promise((resolve) => {
          pendingFetchResolvers[promiseId] = (resolvedResponse) => {
            delete pendingFetchResolvers[promiseId];
            resolve(resolvedResponse);
          };
        });

        let serializedBodyForPostMessage;
        if (typeof bodyForPostMessage === 'string' || bodyForPostMessage == null) {
            serializedBodyForPostMessage = bodyForPostMessage;
        } else if (bodyForPostMessage instanceof ReadableStream) {
            serializedBodyForPostMessage = null;
        } else {
            try {
                serializedBodyForPostMessage = JSON.stringify(bodyForPostMessage);
            } catch (e) {
                serializedBodyForPostMessage = null;
            }
        }

        const messageOptions = {
            method: effectiveOptions.method,
            headers: Object.fromEntries(new Headers(effectiveOptions.headers).entries()),
            body: serializedBodyForPostMessage
        };

        window.parent.postMessage({
          type: 'requestFetch',
          url: actualUrl,
          modelName: modelName,
          options: messageOptions,
          promiseId: promiseId,
        }, '*');

        return promise;
      }
      return originalFetch.apply(window, fetchCallArgs);
    }
    return originalFetch.apply(window, fetchCallArgs);
  };

  window.addEventListener('message', function(event) {
    if (event.data && event.data.type === 'resolveFetch') {
      const { promiseId, response } = event.data;
      if (pendingFetchResolvers[promiseId]) {
        try {
          const reconstructedResponse = new Response(response.body, {
            status: response.status,
            statusText: response.statusText,
            headers: new Headers(response.headers),
          });
          pendingFetchResolvers[promiseId](reconstructedResponse);
        } catch (error) {
          pendingFetchResolvers[promiseId](new Response(null, { status: 500, statusText: "Interceptor Response Reconstruction Error" }));
        }
      }
    }
  });

}))({"textModelName":"gemini-2.5-flash","imageModelName":"imagen-4.0-generate-001","imageEditModelName":"gemini-2.5-flash-image-preview","imageTransformModelName":"gemini-3-pro-image-preview-11-2025","videoModelName":"veo-2.0-generate-001","ttsModelName":"gemini-2.5-flash-preview-tts","deprecatedTextModelNames":["gemini-2.0-flash","gemini-2.5-flash-preview-04-17","gemini-2.5-flash-preview-05-20","gemini-2.5-flash-preview-09-2025"],"deprecatedImageModelNames":["imagen-3.0-generate-001","imagen-3.0-generate-002"]})</script><script>(function(){'use strict';function a(){window.parent.postMessage({type:"interaction"},"*")}window.addEventListener("click",a,{capture:!0,passive:!0});window.addEventListener("touchstart",a,{capture:!0,passive:!0});window.addEventListener("keydown",a,{capture:!0,passive:!0});}).call(this);
</script><script>(function() {
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;

    /**
   * Normalizes an error event or a promise rejection reason into a structured error object.
   * @param {*} errorEventOrReason The error object or reason.
   * @return {object} Structured error data { message, name, stack }.
   */
  function getErrorObject(errorEventOrReason) {
    if (errorEventOrReason instanceof Error) {
      return {
        message: errorEventOrReason.message,
        name: errorEventOrReason.name,
        stack: errorEventOrReason.stack,
      };
    }
    // Fallback for non-Error objects.
    try {
      return {
        message: JSON.stringify(errorEventOrReason),
        name: 'UnknownErrorType',
        stack: null,
      };
    } catch (e) {
      return {
        message: String(errorEventOrReason),
        name: 'UnknownErrorTypeNonStringifiable',
        stack: null,
      };
    }
  }

  /**
   * Converts an array of arguments (from log/error) into a single string.
   * Handles Error objects specially to include their message and stack.
   * @param {Array<*>} args - Arguments passed to console methods.
   * @return {string} A string representation of the arguments.
   */
  function stringifyArgs(args) {
    return args
      .map((arg) => {
        if (arg instanceof Error) {
          const {message, stack} = arg;
          return `Error: ${message}${stack ? ('\nStack: ' + stack) : ''}`;
        }
        if (typeof arg === 'object' && arg !== null) {
          try {
            return JSON.stringify(arg);
          } catch (error) {
            return '[Circular Object]';
          }
        } else {
          return String(arg);
        }
      })
      .join(' ');
  }

  console.log = function(...args) {
    const logString = stringifyArgs(args);
    window.parent.postMessage({ type: 'log', message: logString }, '*');
    originalConsoleLog.apply(console, args);
  };

  console.error = function(...args) {
    let errorData;
    if (args.length > 0 && args[0] instanceof Error) {
      const err = args[0];
      // If the first arg is an Error, capture its details.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        ...getErrorObject(err),
        rawArgsString: stringifyArgs(args.slice(1)),
        timestamp: new Date().toISOString(),
      };
    } else {
      // If not an Error object, treat all args as a general error message.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        message: stringifyArgs(args),
        name: 'ConsoleLoggedError',
        stack: null,
        timestamp: new Date().toISOString(),
      };
    }
    window.parent.postMessage(errorData, '*');
    originalConsoleError.apply(console, args);
  };

  // Listen for global unhandled synchronous errors.
  window.addEventListener('error', function(event) {
    const errorDetails = event.error ? getErrorObject(event.error) : {
      message: event.message,
      name: 'GlobalError',
      stack: null,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
    };

    window.parent.postMessage({
      type: 'error',
      source: 'global',
      ...errorDetails,
      message: errorDetails.message || event.message,
      timestamp: new Date().toISOString(),
    }, '*');
  });

  // Listen for unhandled promise rejections (asynchronous errors).
  window.addEventListener('unhandledrejection', function(event) {
    const errorDetails = getErrorObject(event.reason);

    window.parent.postMessage({
      type: 'error',
      source: 'unhandledrejection',
      ...errorDetails,
      message: errorDetails.message || 'Unhandled Promise Rejection',
      timestamp: new Date().toISOString(),
    }, '*');
  });

})();</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kawaii Street Food Market</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&amp;display=swap" rel="stylesheet">
    <style>
        /* New Kawaii Pastel Color Palette */
        :root {
            --color-primary: #F9A8D4; /* Soft Bubblegum Pink */
            --color-secondary: #FCD34D; /* Cheery Yellow */
            --color-tertiary: #99F6E4; /* Bright Mint */
            --color-background: #FEF3C7; /* Pale Lemon Cream */
            --color-text: #8B5CF6; /* Soft Lavender/Purple */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-background);
            color: var(--color-text);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px 10px;
        }
        #app {
            max-width: 800px;
            width: 100%;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(139, 92, 246, 0.2);
            background-color: white;
            transition: all 0.5s ease-in-out;
        }
        .main-button {
            transition: all 0.1s ease;
            box-shadow: 0 4px 0 var(--color-text);
            border: 2px solid var(--color-text);
        }
        .main-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 var(--color-text);
        }
        .main-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 var(--color-text);
        }
        .stall-card {
            background-color: var(--color-secondary); /* This will be overridden by AI image */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            border: 3px solid var(--color-text);
            position: relative; /* Needed for positioning elements inside */
            overflow: hidden; /* Ensure image fits */
            background-size: cover;
            background-position: center;
            min-height: 120px; /* Ensure a minimum size before image loads */
            display: flex;
            flex-direction: column;
            justify-content: flex-end; /* Push text to bottom */
            color: white; /* Text color over images */
            text-shadow: 0px 0px 5px rgba(0,0,0,0.7);
        }
        .stall-card:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(139, 92, 246, 0.3);
        }
        .choice-button {
            transition: background-color 0.2s, border-color 0.2s;
            border: 2px solid var(--color-text);
            background-color: var(--color-tertiary);
            color: var(--color-text);
        }
        .choice-button.selected {
            background-color: var(--color-primary);
            color: white;
            font-weight: 700;
            border: 2px solid var(--color-text);
            box-shadow: 0 3px 0 var(--color-text);
        }
        .choice-button:not(.selected):hover {
            background-color: #FEEBC8;
        }
        .choice-button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 0 var(--color-text);
        }

        /* Loading Spinner */
        .spinner {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid var(--color-primary); /* Pink */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

<div id="app">
    <!-- Content will be rendered here by JavaScript --></div>

<script type="text/javascript">
    // --- Configuration and State ---
    const apiKey = ""; // API key is left as an empty string and provided by the environment.
    const apiUrlBase = "https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict";

    let state = {
        view: 'mainStreet', // 'mainStreet' or 'customization'
        currentStall: null,
        customization: {},
        generatedImage: null,
        isLoading: false, // For customization image generation
        isLoadingStreet: true, // For street scene and stall images
        streetImage: null,
        errorMessage: null,
    };

    const foodStalls = {
        jianbing: {
            name: "Jianbing (Savory Crepe)",
            icon: "üç≥",
            stallImage: null, // To store AI generated image for the stall
            options: {
                base: { label: "Crepe Base", choices: ["Plain", "Sesame", "Spinach"] },
                protein: { label: "Protein", choices: ["Egg", "Sausage", "Crispy Cracker"] },
                sauce: { label: "Sauce Flavor", choices: ["Sweet Bean Paste", "Chili Oil", "Fermented Tofu Sauce"] },
            }
        },
        tanghulu: {
            name: "Tanghulu (Candied Fruit)",
            icon: "üç°",
            stallImage: null,
            options: {
                fruit: { label: "Main Fruit", choices: ["Strawberry", "Grape", "Hawthorn"] },
                coating: { label: "Candy Coating", choices: ["Clear Sugar", "Honey", "Chocolate Drizzle"] },
                sprinkles: { label: "Topping", choices: ["Sesame Seeds", "Crushed Peanuts", "Edible Glitter"] },
            }
        },
        baozi: {
            name: "Baozi (Steamed Buns)",
            icon: "ü•ü",
            stallImage: null,
            options: {
                filling: { label: "Inner Filling", choices: ["Pork & Cabbage", "Red Bean Paste", "Curry Chicken"] },
                steaming: { label: "Steaming Style", choices: ["Extra Soft", "Slightly Toasted Base"] },
                garnish: { label: "Garnish", choices: ["Scallions", "Black Sesame", "None"] },
            }
        },
        stinkytofu: {
            name: "Stinky Tofu (Chou Doufu)",
            icon: "üí®",
            stallImage: null,
            options: {
                frying: { label: "Frying Style", choices: ["Deep Fried", "Grilled", "Stewed"] },
                sauce: { label: "Dipping Sauce", choices: ["Spicy Chili Garlic", "Mild Soy Sauce", "Sweet & Sour"] },
                toppings: { label: "Side Toppings", choices: ["Pickled Cabbage", "Cilantro", "Chopped Chili"] },
            }
        },
        lambskewers: {
            name: "Cumin Lamb Skewers",
            icon: "üç¢",
            stallImage: null,
            options: {
                meat: { label: "Meat Type", choices: ["Lamb", "Beef", "Mushroom & Tofu"] },
                spice: { label: "Spice Level", choices: ["Mild", "Medium Heat", "Fiery Hot"] },
                flavor: { label: "Seasoning", choices: ["Cumin-Heavy", "Sesame-Oil Rich", "Sichuan Peppercorn"] },
            }
        },
    };

    // --- AI Functions ---

    /**
     * Generic function to call the Imagen API.
     * @param {string} prompt - The text prompt for image generation.
     * @returns {Promise<string|null>} Base64 encoded image data or null on failure.
     */
    async function callImagenAPI(prompt, retries = 3) {
        const payload = {
            instances: { prompt: prompt },
            parameters: { "sampleCount": 1 }
        };

        for (let i = 0; i < retries; i++) {
            try {
                const response = await fetch(apiUrlBase, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    console.warn(`Attempt ${i+1} failed with status: ${response.status}`);
                    throw new Error(`API returned status ${response.status}`);
                }
                
                const result = await response.json();
                const base64Data = result?.predictions?.[0]?.bytesBase64Encoded;
                if (base64Data) {
                    return `data:image/png;base64,${base64Data}`;
                } else {
                    throw new Error("No image data received from the API.");
                }
            } catch (error) {
                console.error(`AI Image generation attempt ${i+1} failed for prompt "${prompt.substring(0, 50)}...":`, error);
                if (i < retries - 1) {
                    const delay = Math.pow(2, i) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay)); // Exponential backoff
                }
            }
        }
        return null; // All retries failed
    }

    /**
     * Generates the plain street scene and individual stall images.
     */
    async function initializeMainStreetVisuals() {
        setState({ isLoadingStreet: true, streetImage: null, errorMessage: null });

        // 1. Generate the plain street image
        const streetPrompt = "A plain, clean, empty, cute, kawaii style Chinese street in a night market setting, pastel colors, soft lighting, no stalls or people, digital art, high quality.";
        const generatedStreetImage = await callImagenAPI(streetPrompt);
        
        if (!generatedStreetImage) {
            setState({ 
                isLoadingStreet: false, 
                streetImage: 'https://placehold.co/800x400/F9A8D4/8B5CF6?text=Street+Visual+Error',
                errorMessage: "Could not generate the main street visual."
            });
            return;
        }

        // 2. Generate images for each stall
        const stallImagePromises = Object.keys(foodStalls).map(async key => {
            const stall = foodStalls[key];
            const stallPrompt = `A cute, kawaii, small Chinese street food stall selling ${stall.name.split('(')[0].trim()}, glowing lanterns, pastel colors, soft lighting, digital art, isolated, white background for easy overlay.`;
            const stallImg = await callImagenAPI(stallPrompt);
            foodStalls[key].stallImage = stallImg || 'https://placehold.co/150x100/FCD34D/8B5CF6?text=Stall+Error'; // Fallback
        });

        await Promise.all(stallImagePromises); // Wait for all stall images to generate

        setState({ 
            isLoadingStreet: false, 
            streetImage: generatedStreetImage,
            errorMessage: generatedStreetImage ? null : state.errorMessage // Clear error if street image generated
        });
    }

    // --- Core Functions ---

    function setState(newState) {
        state = { ...state, ...newState };
        render();
    }

    function goToStall(stallKey) {
        const stall = foodStalls[stallKey];
        if (!stall) return;

        const initialCustomization = {};
        for (const optionKey in stall.options) {
            initialCustomization[optionKey] = stall.options[optionKey].choices[0];
        }

        setState({
            view: 'customization',
            currentStall: stallKey,
            customization: initialCustomization,
            generatedImage: null,
            errorMessage: null,
        });
    }

    function selectOption(optionKey, choice) {
        const newCustomization = { ...state.customization, [optionKey]: choice };
        setState({ customization: newCustomization });
    }

    function buildCustomFoodPrompt() {
        const stall = foodStalls[state.currentStall];
        const foodName = stall.name.split('(')[0].trim();
        const choices = Object.values(state.customization).join(', ');

        return `A beautiful, close-up photo of a hyper-kawaii ${foodName} with the following features: ${choices}. Style: highly detailed, pastel colors, cute lighting, digital art, soft textures. The background is an abstract, clean version of a Chinese street stall.`;
    }

    async function generateImage() {
        const prompt = buildCustomFoodPrompt();
        setState({ isLoading: true, generatedImage: null, errorMessage: null });
        
        const generatedFoodImage = await callImagenAPI(prompt);

        if (generatedFoodImage) {
            setState({
                isLoading: false,
                generatedImage: generatedFoodImage
            });
        } else {
            setState({
                isLoading: false,
                errorMessage: "Failed to generate your custom food art after several tries. Check your network or try a different combination!"
            });
        }
    }

    // --- Rendering Functions ---

    function renderMainStreet() {
        if (state.isLoadingStreet) {
             return `
                <div class="p-8 flex flex-col items-center justify-center min-h-[400px]">
                    <h1 class="text-3xl font-extrabold text-center mb-4" style="color: var(--color-text);">
                        Building The Kawaii Market...
                    </h1>
                    <div class="spinner mb-4" style="border-top-color: var(--color-primary);"></div>
                    <p class="font-semibold text-lg animate-pulse">Generating your unique street and stalls...</p>
                </div>
            `;
        }

        const stallKeys = Object.keys(foodStalls);
        
        return `
            <div class="p-6">
                <h1 class="text-3xl font-extrabold text-center mb-2" style="color: var(--color-primary);">
                    Welcome to the Kawaii Street Food Market! üèÆ
                </h1>
                <p class="text-center mb-4 text-md font-medium">
                    Click a charming stall below to start customizing your cute Chinese treat.
                </p>
            </div>
            
            <div class="relative w-full h-[450px] rounded-b-xl overflow-hidden mb-6 shadow-2xl" 
                 style="border-top: 5px solid var(--color-primary);">
                
                <!-- AI Generated Plain Street Scene --><img src="${state.streetImage}" alt="Kawaii Street Scene" 
                     class="absolute inset-0 w-full h-full object-cover">
                
                <!-- Interactive Stalls Overlayed --><div class="absolute inset-0 p-4 grid grid-cols-2 md:grid-cols-3 gap-4 place-items-center">
                    ${stallKeys.map((key, index) => {
                        const stall = foodStalls[key];
                        return `
                            <div
                                class="stall-card p-2 rounded-xl text-center w-full max-w-[200px] h-[150px] relative transition-transform hover:scale-105"
                                onclick="goToStall('${key}')"
                                style="background-image: url('${stall.stallImage}'); background-size: cover; background-position: center; border: 3px solid var(--color-text); box-shadow: 0 4px 0 var(--color-text);"
                            >
                                <div class="absolute inset-0 bg-black opacity-30 rounded-lg"></div> <!-- Overlay for text readability --><h3 class="relative z-10 text-lg font-extrabold text-white mt-auto leading-tight p-2">${stall.name.split('(')[0].trim()}</h3>
                            </div>
                        `;
                    }).join('')}
                </div>
            </div>
            ${state.errorMessage && state.view === 'mainStreet' ? `<p class="text-center text-sm text-red-500">${state.errorMessage}</p>` : ''}
        `;
    }

    function renderCustomization() {
        const stallKey = state.currentStall;
        const stall = foodStalls[stallKey];
        const customizations = state.customization;

        let customizationHtml = '';

        for (const optionKey in stall.options) {
            const option = stall.options[optionKey];
            const currentChoice = customizations[optionKey];

            customizationHtml += `
                <div class="mb-5 p-4 rounded-xl border border-gray-200 bg-gray-50">
                    <h4 class="text-lg font-bold mb-3 border-b-2 pb-1" style="border-color: var(--color-tertiary); color: var(--color-text);">
                        ${option.label}: 
                        <span class="text-base font-medium" style="color: var(--color-primary);">${currentChoice}</span>
                    </h4>
                    <div class="flex flex-wrap gap-2">
                        ${option.choices.map(choice => `
                            <button
                                class="choice-button px-4 py-2 rounded-full text-sm font-medium ${currentChoice === choice ? 'selected' : ''}"
                                onclick="selectOption('${optionKey}', '${choice}')"
                            >
                                ${choice}
                            </button>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        return `
            <div class="p-6">
                <h1 class="text-3xl font-extrabold text-center mb-4" style="color: var(--color-primary);">
                    Customize Your ${stall.name.split('(')[0].trim()}! ${stall.icon}
                </h1>
                <p class="text-center mb-6 text-base font-medium">
                    Mix and match ingredients to create your one-of-a-kind dish!
                </p>
                
                ${customizationHtml}

                <div class="flex flex-col sm:flex-row justify-center gap-4 mt-8">
                    <button
                        class="main-button px-6 py-3 rounded-xl text-white font-bold"
                        onclick="setState({ view: 'mainStreet', generatedImage: null, errorMessage: null })"
                        style="background-color: var(--color-text);"
                    >
                        ‚¨ÖÔ∏è Back to Market
                    </button>
                    <button
                        class="main-button px-6 py-3 rounded-xl text-white font-bold"
                        onclick="generateImage()"
                        style="background-color: var(--color-primary);"
                        ${state.isLoading ? 'disabled' : ''}
                    >
                        ${state.isLoading ? '...Generating Cute Food Art' : 'üé® Create & Visualize My Dish!'}
                    </button>
                </div>
                
                ${renderImageOutput()}
            </div>
        `;
    }

    function renderImageOutput() {
        if (state.isLoading) {
            return `
                <div class="flex flex-col items-center justify-center mt-10 p-6 rounded-xl bg-gray-50">
                    <div class="spinner mb-4" style="border-top-color: var(--color-primary);"></div>
                    <p class="font-semibold text-lg animate-pulse">The chefs are busy cooking and drawing...</p>
                    <p class="text-sm text-gray-500 mt-1">Generating your unique, kawaii food art now!</p>
                </div>
            `;
        }
        
        if (state.errorMessage && state.view === 'customization') {
            return `
                <div class="mt-10 p-6 rounded-xl bg-red-100 border border-red-400 text-red-700 text-center">
                    <p class="font-bold mb-2">üò≠ Oh no! A culinary catastrophe occurred.</p>
                    <p class="text-sm">${state.errorMessage}</p>
                </div>
            `;
        }

        if (state.generatedImage) {
            const currentStall = foodStalls[state.currentStall];
            const foodName = currentStall.name.split('(')[0].trim();
            return `
                <div class="mt-10 p-6 rounded-xl shadow-2xl bg-white border-4 border-dashed" style="border-color: var(--color-tertiary);">
                    <h3 class="text-2xl font-extrabold text-center mb-4" style="color: var(--color-text);">
                        üíñ Your Perfect ${foodName} is Ready! üíñ
                    </h3>
                    <div class="flex justify-center">
                        <img 
                            src="${state.generatedImage}" 
                            alt="Generated Kawaii Street Food" 
                            class="w-full max-w-sm rounded-xl shadow-2xl transition duration-500 ease-in-out transform hover:scale-[1.02]"
                        >
                    </div>
                    <p class="text-center text-sm mt-4 text-gray-600">
                        *This is a unique, AI-generated illustration based on your order.*
                    </p>
                </div>
            `;
        }

        return '';
    }

    /**
     * Main render function
     */
    function render() {
        const app = document.getElementById('app');
        if (!app) return;

        let content = '';
        if (state.view === 'mainStreet') {
            content = renderMainStreet();
        } else if (state.view === 'customization') {
            content = renderCustomization();
        }

        app.innerHTML = content;
    }

    // Expose functions globally for HTML event handlers
    window.goToStall = goToStall;
    window.selectOption = selectOption;
    window.generateImage = generateImage;
    window.setState = setState;

    // Initial load: Start generating the street scene and all stall visuals
    window.onload = () => {
        initializeMainStreetVisuals();
        render(); // Initial render shows the loading state
    };

</script>

</body></html>