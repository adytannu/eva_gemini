<!DOCTYPE html>
<html lang="en"><head><script>(function(firebaseConfig, initialAuthToken, appId) {
        window.__firebase_config = firebaseConfig;
        window.__initial_auth_token = initialAuthToken;
        window.__app_id = appId;
            })("\n{\n  \"apiKey\": \"AIzaSyCqyCcs2R2e7AegGjvFAwG98wlamtbHvZY\",\n  \"authDomain\": \"bard-frontend.firebaseapp.com\",\n  \"projectId\": \"bard-frontend\",\n  \"storageBucket\": \"bard-frontend.firebasestorage.app\",\n  \"messagingSenderId\": \"175205271074\",\n  \"appId\": \"1:175205271074:web:2b7bd4d34d33bf38e6ec7b\"\n}\n","eyJhbGciOiJSUzI1NiIsImtpZCI6IjY0ZjA3ZDcxOTc5ZjQzODI3MjJhOGRmMzQwNzUzY2UwZmVkOThjYTgiLCJ0eXAiOiJKV1QifQ.eyJzdWIiOiJmaXJlYmFzZS1hZG1pbnNkay1mYnN2Y0BiYXJkLWZyb250ZW5kLmlhbS5nc2VydmljZWFjY291bnQuY29tIiwiYXVkIjoiaHR0cHM6Ly9pZGVudGl0eXRvb2xraXQuZ29vZ2xlYXBpcy5jb20vZ29vZ2xlLmlkZW50aXR5LmlkZW50aXR5dG9vbGtpdC52MS5JZGVudGl0eVRvb2xraXQiLCJ1aWQiOiIxMjc1ODM2MTU4NDMzNTIyMzc4MCIsImlzcyI6ImZpcmViYXNlLWFkbWluc2RrLWZic3ZjQGJhcmQtZnJvbnRlbmQuaWFtLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJjbGFpbXMiOnsiYXBwSWQiOiIyZGYwMGQwNDFjYjItcHVkZGluZ19tYWtlci5odG1sLTg1MyJ9LCJleHAiOjE3NzE1NjY3MzAsImlhdCI6MTc3MTU2MzEzMCwiYWxnIjoiUlMyNTYifQ.k6lvaHl7HjKhjIg2p6apFzSAHAzk5k3Ud8Iw5DZbb1DsdhRFtW6NRZwMABohsShPE7uzW7TfSycWdOZKkEmFwvdQfaYbZCdFRPf4LTcN5cBDRjL98yCTBafwhwzRxCLR3Spg7LHTBmRCgFIoBQK0611XQqhX17SUG6blJg0mV9uPo_Nlf5qRAi5yiq3r_HFzK3SQqXCQHON2-ZVCXgZ-DBcEj0_MUvuILff4E3uDrIcpvIn7eq2RvohmGi1B8ZmEMGNP5Hib6LN9geIgy_P19ZEJAHjzEZEGS83e3wdqUxbqzO9QO20N2WDuZPgo9k_tpVhGTszdz8-6EPFaAB7HtA","2df00d041cb2-pudding_maker.html-853")</script><script>(function(){'use strict';var h=typeof Object.defineProperties=="function"?Object.defineProperty:function(a,b,d){if(a==Array.prototype||a==Object.prototype)return a;a[b]=d.value;return a};function l(a){a=["object"==typeof globalThis&&globalThis,a,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var b=0;b<a.length;++b){var d=a[b];if(d&&d.Math==Math)return d}throw Error("Cannot find global object");}var n=l(this);
function p(a,b){if(b)a:{var d=n;a=a.split(".");for(var c=0;c<a.length-1;c++){var e=a[c];if(!(e in d))break a;d=d[e]}a=a[a.length-1];c=d[a];b=b(c);b!=c&&b!=null&&h(d,a,{configurable:!0,writable:!0,value:b})}}function r(a){function b(c){return a.next(c)}function d(c){return a.throw(c)}return new Promise(function(c,e){function f(g){g.done?c(g.value):Promise.resolve(g.value).then(b,d).then(f,e)}f(a.next())})}function t(a){return r(a())}
p("Object.values",function(a){return a?a:function(b){var d=[],c;for(c in b)Object.prototype.hasOwnProperty.call(b,c)&&d.push(b[c]);return d}});p("Array.prototype.includes",function(a){return a?a:function(b,d){var c=this;c instanceof String&&(c=String(c));var e=c.length;d=d||0;for(d<0&&(d=Math.max(d+e,0));d<e;d++){var f=c[d];if(f===b||Object.is(f,b))return!0}return!1}});/*

 MIT License

 Copyright (c) 2017-2023 W.Y.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

*/
function u(a,b){const d=a.style;b.backgroundColor&&(d.backgroundColor=b.backgroundColor);b.width&&(d.width=`${b.width}px`);b.height&&(d.height=`${b.height}px`);const c=b.style;c!=null&&Object.keys(c).forEach(e=>{d[e]=c[e]})};var v=(()=>{let a=0;return()=>{a+=1;return`u${`0000${(Math.random()*1679616<<0).toString(36)}`.slice(-4)}${a}`}})();function w(a){const b=[];for(let d=0,c=a.length;d<c;d++)b.push(a[d]);return b}let x=null;function y(a={}){return x?x:a.l?x=a.l:x=w(window.getComputedStyle(document.documentElement))}function z(a,b){return(a=(a.ownerDocument.defaultView||window).getComputedStyle(a).getPropertyValue(b))?parseFloat(a.replace("px","")):0}
function A(a,b={}){var d;if(!(d=b.width)){d=z(a,"border-left-width");var c=z(a,"border-right-width");d=a.clientWidth+d+c}(b=b.height)||(b=z(a,"border-top-width"),c=z(a,"border-bottom-width"),b=a.clientHeight+b+c);return{width:d,height:b}}function B(a){return new Promise((b,d)=>{const c=new Image;c.onload=()=>{c.decode().then(()=>{requestAnimationFrame(()=>b(c))})};c.onerror=d;c.crossOrigin="anonymous";c.decoding="async";c.src=a})}
function C(a){return t(function*(){return Promise.resolve().then(()=>(new XMLSerializer).serializeToString(a)).then(encodeURIComponent).then(b=>`data:image/svg+xml;charset=utf-8,${b}`)})}
function D(a,b,d){return t(function*(){const c=document.createElementNS("http://www.w3.org/2000/svg","svg"),e=document.createElementNS("http://www.w3.org/2000/svg","foreignObject");c.setAttribute("width",`${b}`);c.setAttribute("height",`${d}`);c.setAttribute("viewBox",`0 0 ${b} ${d}`);e.setAttribute("width","100%");e.setAttribute("height","100%");e.setAttribute("x","0");e.setAttribute("y","0");e.setAttribute("externalResourcesRequired","true");c.appendChild(e);e.appendChild(a);return C(c)})}
var E=(a,b)=>{if(a instanceof b)return!0;a=Object.getPrototypeOf(a);return a===null?!1:a.constructor.name===b.name||E(a,b)};function F(a,b){return y(b).map(d=>{const c=a.getPropertyValue(d),e=a.getPropertyPriority(d);return`${d}: ${c}${e?" !important":""};`}).join(" ")}
function G(a,b,d,c){a=window.getComputedStyle(a,d);var e=a.getPropertyValue("content");if(e!==""&&e!=="none"){var f=v();try{b.className=`${b.className} ${f}`}catch(k){return}e=document.createElement("style");var g=e.appendChild;d=`.${f}:${d}`;a.cssText?(c=a.getPropertyValue("content"),c=`${a.cssText} content: '${c.replace(/'|"/g,"")}';`):c=F(a,c);g.call(e,document.createTextNode(`${d}{${c}}`));b.appendChild(e)}};function H(a){return a.search(/^(data:)/)!==-1}function I(a,b,d){return t(function*(){const c=yield fetch(a,b);if(c.status===404)throw Error(`Resource "${c.url}" not found`);const e=yield c.blob();return new Promise((f,g)=>{const k=new FileReader;k.onerror=g;k.onloadend=()=>{try{f(d({o:c,result:k.result}))}catch(m){g(m)}};k.readAsDataURL(e)})})}const J={};function K(a,b,d){let c=a.replace(/\?.*/,"");d&&(c=a);/ttf|otf|eot|woff2?/i.test(c)&&(c=c.replace(/.*\//,""));return b?`[${b}]${c}`:c}
function L(a,b,d){return t(function*(){const c=K(a,b,d.C);if(J[c]!=null)return J[c];d.u&&(a+=(/\?/.test(a)?"&":"?")+(new Date).getTime());let e;try{const f=yield I(a,d.i,({o:g,result:k})=>{b||(b=g.headers.get("Content-Type")||"");return k.split(/,/)[1]});e=`data:${b};base64,${f}`}catch(f){e=d.B||""}return J[c]=e})};const M={P:"application/font-woff",R:"application/font-woff",N:"application/font-truetype",v:"application/vnd.ms-fontobject",H:"image/png",F:"image/jpeg",D:"image/jpeg",A:"image/gif",M:"image/tiff",L:"image/svg+xml",O:"image/webp"};function N(a){return(a=/\.([^./]*?)$/g.exec(a))?a[1]:""};function O(a){return t(function*(){const b=a.toDataURL();return b==="data:,"?a.cloneNode(!1):B(b)})}function aa(a,b){return t(function*(){if(a.currentSrc){var d=document.createElement("canvas");const c=d.getContext("2d");d.width=a.clientWidth;d.height=a.clientHeight;c==null||c.drawImage(a,0,0,d.width,d.height);d=d.toDataURL();return B(d)}d=a.poster;d=yield L(d,M[N(d).toLowerCase()]||"",b);return B(d)})}
function ba(a,b){return t(function*(){try{let d;if(a==null?0:(d=a.contentDocument)==null?0:d.body)return yield P(a.contentDocument.body,b,!0)}catch(d){}return a.cloneNode(!1)})}function ca(a,b){return t(function*(){return E(a,HTMLCanvasElement)?O(a):E(a,HTMLVideoElement)?aa(a,b):E(a,HTMLIFrameElement)?ba(a,b):a.cloneNode(a.tagName!=null&&a.tagName.toUpperCase()==="SVG")})}
function da(a,b,d){return t(function*(){if(b.tagName!=null&&b.tagName.toUpperCase()==="SVG")return b;let c=[];if(a.tagName!=null&&a.tagName.toUpperCase()==="SLOT"&&a.assignedNodes)c=w(a.assignedNodes());else{let e;if(E(a,HTMLIFrameElement)&&((e=a.contentDocument)==null?0:e.body))c=w(a.contentDocument.body.childNodes);else{let f;c=w(((f=a.shadowRoot)!=null?f:a).childNodes)}}if(c.length===0||E(a,HTMLVideoElement))return b;yield c.reduce((e,f)=>e.then(()=>P(f,d)).then(g=>{g&&b.appendChild(g)}),Promise.resolve());
return b})}function ea(a,b,d){const c=b.style;if(c){var e=window.getComputedStyle(a);e.cssText?(c.cssText=e.cssText,c.transformOrigin=e.transformOrigin):y(d).forEach(f=>{let g=e.getPropertyValue(f);f==="font-size"&&g.endsWith("px")&&(g=`${Math.floor(parseFloat(g.substring(0,g.length-2)))-.1}px`);E(a,HTMLIFrameElement)&&f==="display"&&g==="inline"&&(g="block");f==="d"&&b.getAttribute("d")&&(g=`path(${b.getAttribute("d")})`);c.setProperty(f,g,e.getPropertyPriority(f))})}}
function fa(a,b){E(a,HTMLSelectElement)&&(b=Array.from(b.children).find(d=>a.value===d.getAttribute("value")))&&b.setAttribute("selected","")}
function ha(a,b){return t(function*(){var d=a.querySelectorAll?a.querySelectorAll("use"):[];if(d.length===0)return a;var c={};for(var e=0;e<d.length;e++){var f=d[e].getAttribute("xlink:href");if(f){const g=document.querySelector(f);a.querySelector(f)||!g||c[f]||(c[f]=yield P(g,b,!0))}}d=Object.values(c);if(d.length){c=document.createElementNS("http://www.w3.org/1999/xhtml","svg");c.setAttribute("xmlns","http://www.w3.org/1999/xhtml");c.style.position="absolute";c.style.width="0";c.style.height="0";
c.style.overflow="hidden";c.style.display="none";e=document.createElementNS("http://www.w3.org/1999/xhtml","defs");c.appendChild(e);for(f=0;f<d.length;f++)e.appendChild(d[f]);a.appendChild(c)}return a})}
function P(a,b,d){return t(function*(){return d||!b.filter||b.filter(a)?Promise.resolve(a).then(c=>ca(c,b)).then(c=>da(a,c,b)).then(c=>{E(c,Element)&&(ea(a,c,b),G(a,c,":before",b),G(a,c,":after",b),E(a,HTMLTextAreaElement)&&(c.textContent=a.value),E(a,HTMLInputElement)&&c.setAttribute("value",a.value),fa(a,c));return c}).then(c=>ha(c,b)):null})};const Q=/url\((['"]?)([^'"]+?)\1\)/g,ia=/url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g,ja=/src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;function ka(a){const b=[];a.replace(Q,(d,c,e)=>{b.push(e);return d});return b.filter(d=>!H(d))}
function la(a,b,d,c){return t(function*(){try{const e=d?(new URL(b,d||void 0)).toString():b;let f;f=yield L(e,M[N(b).toLowerCase()]||"",c);return a.replace(new RegExp(`(url\\(['"]?)(${b.replace(/([.*+?^${}()|\[\]\/\\])/g,"\\$1")})(['"]?\\))`,"g"),`$1${f}$3`)}catch(e){}return a})}function ma(a,{I:b}){return b?a.replace(ja,d=>{for(;;){const [c,,e]=ia.exec(d)||[],f=c,g=e;if(!g)return"";if(g===b)return`src: ${f};`}}):a}
function R(a,b,d){return t(function*(){if(a.search(Q)===-1)return a;const c=ma(a,d);return ka(c).reduce((e,f)=>e.then(g=>la(g,f,b,d)),Promise.resolve(c))})};function S(a,b,d){return t(function*(){var c;const e=(c=b.style)==null?void 0:c.getPropertyValue(a);return e?(c=yield R(e,null,d),b.style.setProperty(a,c,b.style.getPropertyPriority(a)),!0):!1})}function na(a,b){return t(function*(){(yield S("background",a,b))||(yield S("background-image",a,b));(yield S("mask",a,b))||(yield S("-webkit-mask",a,b))||(yield S("mask-image",a,b))||(yield S("-webkit-mask-image",a,b))})}
function oa(a,b){return t(function*(){const d=E(a,HTMLImageElement);if(d&&!H(a.src)||E(a,SVGImageElement)&&!H(a.href.baseVal)){var c=d?a.src:a.href.baseVal,e=yield L(c,M[N(c).toLowerCase()]||"",b);yield new Promise((f,g)=>{a.onload=f;a.onerror=b.m?(...k)=>{try{f(b.m(...k))}catch(m){g(m)}}:g;a.decode&&(a.decode=f);a.loading==="lazy"&&(a.loading="eager");d?(a.srcset="",a.src=e):a.href.baseVal=e})}})}
function pa(a,b){return t(function*(){const d=w(a.childNodes).map(c=>T(c,b));yield Promise.all(d).then(()=>a)})}function T(a,b){return t(function*(){E(a,Element)&&(yield na(a,b),yield oa(a,b),yield pa(a,b))})};const U={};function V(a){return t(function*(){var b=U[a];if(b!=null)return b;b=yield(yield fetch(a)).text();b={url:a,cssText:b};return U[a]=b})}function W(a,b){return t(function*(){let d=a.cssText;const c=/url\(["']?([^"')]+)["']?\)/g,e=(d.match(/url\([^)]+\)/g)||[]).map(f=>t(function*(){let g=f.replace(c,"$1");g.startsWith("https://")||(g=(new URL(g,a.url)).href);return I(g,b.i,({result:k})=>{d=d.replace(f,`url(${k})`);return[f,k]})}));return Promise.all(e).then(()=>d)})}
function X(a){if(a==null)return[];const b=[];a=a.replace(/(\/\*[\s\S]*?\*\/)/gi,"");for(var d=RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})","gi");;){var c=d.exec(a);if(c===null)break;b.push(c[0])}a=a.replace(d,"");d=/@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;for(c=RegExp("((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})","gi");;){let e=d.exec(a);if(e===null)if(e=c.exec(a),e===null)break;else d.lastIndex=c.lastIndex;else c.lastIndex=
d.lastIndex;b.push(e[0])}return b}
function qa(a,b){return t(function*(){const d=[],c=[];a.forEach(e=>{if("cssRules"in e)try{w(e.cssRules||[]).forEach((f,g)=>{if(f.type===CSSRule.IMPORT_RULE){let k=g+1;f=V(f.href).then(m=>W(m,b)).then(m=>X(m).forEach(q=>{try{e.insertRule(q,q.startsWith("@import")?k+=1:e.cssRules.length)}catch(Da){}})).catch(()=>{});c.push(f)}})}catch(f){const g=a.find(k=>k.href==null)||document.styleSheets[0];e.href!=null&&c.push(V(e.href).then(k=>W(k,b)).then(k=>X(k).forEach(m=>{g.insertRule(m,g.cssRules.length)})).catch(()=>
{}))}});return Promise.all(c).then(()=>{a.forEach(e=>{if("cssRules"in e)try{w(e.cssRules||[]).forEach(f=>{d.push(f)})}catch(f){}});return d})})}function ra(a){return a.filter(b=>b.type===CSSRule.FONT_FACE_RULE).filter(b=>b.style.getPropertyValue("src").search(Q)!==-1)}function sa(a,b){return t(function*(){if(a.ownerDocument==null)throw Error("Provided element is not within a Document");var d=w(a.ownerDocument.styleSheets);d=yield qa(d,b);return ra(d)})}
function ta(a){function b(c){(c.style.fontFamily||getComputedStyle(c).fontFamily).split(",").forEach(e=>{d.add(e.trim().replace(/["']/g,""))});Array.from(c.children).forEach(e=>{e instanceof HTMLElement&&b(e)})}const d=new Set;b(a);return d}function ua(a,b){return t(function*(){const d=yield sa(a,b),c=ta(a);return(yield Promise.all(d.filter(e=>c.has(e.style.fontFamily.trim().replace(/["']/g,""))).map(e=>R(e.cssText,e.parentStyleSheet?e.parentStyleSheet.href:null,b)))).join("\n")})}
function va(a,b){return t(function*(){const d=b.j!=null?b.j:b.K?null:yield ua(a,b);if(d){const c=document.createElement("style");c.appendChild(document.createTextNode(d));a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)}})};function wa(a,b={}){return t(function*(){const {width:d,height:c}=A(a,b),e=yield P(a,b,!0);yield va(e,b);yield T(e,b);u(e,b);return yield D(e,d,c)})}
function xa(a,b={}){return t(function*(){const {width:d,height:c}=A(a,b);var e=yield wa(a,b);e=yield B(e);const f=document.createElement("canvas"),g=f.getContext("2d"),k=b.G||window.devicePixelRatio||1,m=b.h||d,q=b.g||c;f.width=m*k;f.height=q*k;!b.J&&(f.width>16384||f.height>16384)&&(f.width>16384&&f.height>16384?f.width>f.height?(f.height*=16384/f.width,f.width=16384):(f.width*=16384/f.height,f.height=16384):f.width>16384?(f.height*=16384/f.width,f.width=16384):(f.width*=16384/f.height,f.height=
16384));f.style.width=`${m}`;f.style.height=`${q}`;b.backgroundColor&&(g.fillStyle=b.backgroundColor,g.fillRect(0,0,f.width,f.height));g.drawImage(e,0,0,f.width,f.height);return f})}function ya(a,b={}){return t(function*(){return(yield xa(a,b)).toDataURL()})};const za=["gemini.google.com","corp.google.com","proxy.googlers.com"];function Y(){return document.body.querySelectorAll('[class*="animate"]').length>0}function Z(a){return t(function*(){try{return yield ya(a,{h:a.offsetWidth,g:a.offsetHeight})}catch(d){var b=a.offsetHeight;const c=document.createElement("canvas");c.width=a.offsetWidth;c.height=b;return c.toDataURL("image/png")}})}
function Aa(){return t(function*(){const a=document.body.offsetWidth,b=document.body.offsetHeight,d=document.body.cloneNode(!0);d.querySelectorAll('[class*="animate"]').forEach(c=>{c.classList.remove(...Array.from(c.classList).filter(e=>e.startsWith("animate")))});d.style.width=`${a}px`;d.style.height=`${b}px`;return d})}
function Ba(a){return t(function*(){let b=document.body;if(Y()){var d=yield Aa();b=d;document.body.appendChild(d)}d=yield Z(b);Y()&&document.body.removeChild(b);window.parent.postMessage({type:"SEND_SCREENSHOT",image:d,topOffset:document.documentElement.scrollTop},a.origin)})}function Ca(a){return t(function*(){const b={type:"SEND_SCREENSHOT_FOR_DATA_VISUALIZATION",image:yield Z(document.body),topOffset:0};window.parent.postMessage(b,a.origin)})}
window.addEventListener("message",a=>t(function*(){if(za.some(d=>a.origin.includes(d))){var b=a.data;b&&(b.type==="MAKE_SCREENSHOT"&&(yield Ba(a)),b.type==="MAKE_SCREENSHOT_FOR_DATA_VISUALIZATION"&&(yield Ca(a)))}}));
})();</script><script>(function() {
  // Ensure this script is executed only once
  if (window.firebaseAuthBridgeScriptLoaded) {
    return;
  }
  window.firebaseAuthBridgeScriptLoaded = true;

  let nextTokenPromiseId = 0;

  // Stores { resolve, reject } for ongoing token requests
  const pendingTokenPromises = {};

  // Listen for messages from the Host Application
  window.addEventListener('message', function(event) {

    const messageData = event.data;

  if (messageData && messageData.type === 'RESOLVE_NEW_FIREBASE_TOKEN') {
      const { success, token, error, promiseId } = messageData ?? {};
      if (pendingTokenPromises[promiseId]) {
        if (success) {
          pendingTokenPromises[promiseId].resolve(token);
        } else {
          pendingTokenPromises[promiseId].reject(new Error(error || 'Token refresh failed from host.'));
        }
        delete pendingTokenPromises[promiseId];
      }
    }
  });

  // Expose a function for the Generated App to request a new Firebase token
  window.requestNewFirebaseToken = function() {
    const currentPromiseId = nextTokenPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingTokenPromises[currentPromiseId] = { resolve, reject };
    });
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({
        type: 'REQUEST_NEW_FIREBASE_TOKEN',
        promiseId: currentPromiseId
      }, '*');
    } else {
      pendingTokenPromises[currentPromiseId].reject(new Error('No parent window to request token from.'));
      delete pendingTokenPromises[currentPromiseId];
    }
    return promise;
  };
})();</script><script>
let realOriginalGetUserMedia = null;
if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
  realOriginalGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
}

(function() {
  if (navigator.mediaDevices && navigator.mediaDevices.__proto__) {
    try {
      Object.defineProperty(navigator.mediaDevices.__proto__, 'getUserMedia', {
        get: function() {
          return undefined; // Or throw an error
        },
        configurable: false
      });
    } catch (error) {
      console.error("Error defining prototype getter:", error);
    }
  }
})();

(function() {
  const pendingMediaResolvers = {};
  let nextMediaPromiseId = 0;

  function requestMediaPermissions(constraints) {
    const mediaPromiseId = nextMediaPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingMediaResolvers[mediaPromiseId] = (granted) => {
        delete pendingMediaResolvers[mediaPromiseId];
        resolve(granted);
      };
    });

    window.parent.postMessage({
      type: 'requestMediaPermission',
      constraints: constraints,
      promiseId: mediaPromiseId,
    }, '*');

    return promise;
  }

  let originalGetUserMedia = realOriginalGetUserMedia;

  function interceptGetUserMedia() {
    if (navigator.mediaDevices) {
      Object.defineProperty(navigator.mediaDevices, 'getUserMedia', {
        value: function(constraints) {
          return requestMediaPermissions(constraints).then((granted) => {
            if (granted) {
              if (originalGetUserMedia) {
                return originalGetUserMedia(constraints);
              } else {
                throw new Error("Original getUserMedia not available.");
              }
            } else {
              throw new DOMException('Permission denied', 'NotAllowedError');
            }
          });
        },
        writable: false,
        configurable: false
      });
    }
  }

  interceptGetUserMedia();

  const observer = new MutationObserver(function(mutationsList, observer) {
    for (const mutation of mutationsList) {
      if (mutation.type === 'reconfigured' && mutation.name === 'getUserMedia' && mutation.object === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'attributes' && mutation.attributeName === 'getUserMedia' && mutation.target === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'childList' && mutation.addedNodes) {
        mutation.addedNodes.forEach(node => {
          if (node === navigator.mediaDevices) {
            interceptGetUserMedia();
          }
        });
      }
    }
  });

  function interceptSpeechRecognition() {
    if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
      return;
    }

    const OriginalSpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

    const SpeechRecognitionWrapper = function(...args) {
      const recognizer = new OriginalSpeechRecognition(...args);
      const originalStart = recognizer.start.bind(recognizer);

      recognizer.start = function() {
        requestMediaPermissions({ audio: true }).then(granted => {
          if (granted) {
            originalStart();
          } else {
            const errorEvent = new SpeechRecognitionErrorEvent('error');
            errorEvent.error = 'not-allowed'; // This is the standard error for permission denial.
            recognizer.dispatchEvent(errorEvent);
          }
        });
      };

      return recognizer;
    };

    SpeechRecognitionWrapper.prototype = OriginalSpeechRecognition.prototype;
    SpeechRecognitionWrapper.prototype.constructor = SpeechRecognitionWrapper;

    if (window.SpeechRecognition) {
      window.SpeechRecognition = SpeechRecognitionWrapper;
    }
    if (window.webkitSpeechRecognition) {
      window.webkitSpeechRecognition = SpeechRecognitionWrapper;
    }
  }

  interceptSpeechRecognition();

  window.addEventListener('message', function(event) {
    if (event.data) {
      if (event.data.type === 'resolveMediaPermission') {
        const { promiseId, granted } = event.data;
        if (pendingMediaResolvers[promiseId]) {
          pendingMediaResolvers[promiseId](granted);
        }
      }
    }
  });

})();</script><script>((function(modelInformation) {
  const originalFetch = window.fetch;
  // TODO: b/421908508 - Move these out of the script and match all generative AI model calls.
  let googleLlmBaseApiUrls = [
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':streamGenerateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageEditModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageTransformModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.ttsModelName + ':generateContent',
  ];
  modelInformation.deprecatedTextModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':streamGenerateContent',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':generateContent',
    );
  });
  modelInformation.deprecatedImageModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':predict',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':predictLongRunning',
    );
  });

  const pendingFetchResolvers = {};
  let nextPromiseId = 0;

  function handleStringInput(input, optionsArgument) {
    const actualUrl = input;
    const fetchCallArgs = [actualUrl, optionsArgument];
    const effectiveOptions = optionsArgument || {};
    const bodyForApiKeyCheck = effectiveOptions.body;
    const bodyForPostMessage = effectiveOptions.body;
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  function handleRequestInput(input, optionsArgument) {
    const actualUrl = input.url;
    const fetchCallArgs = [input, optionsArgument];
    const effectiveOptions = { method: input.method, headers: new Headers(input.headers) };
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (optionsArgument) {
      if (optionsArgument.method) effectiveOptions.method = optionsArgument.method;
      if (optionsArgument.headers) effectiveOptions.headers = new Headers(optionsArgument.headers);
      if ('body' in optionsArgument) {
        bodyForApiKeyCheck = optionsArgument.body;
        bodyForPostMessage = optionsArgument.body;
      } else {
        bodyForApiKeyCheck = undefined;
        bodyForPostMessage = input.body;
      }
    } else {
      bodyForApiKeyCheck = undefined;
      bodyForPostMessage = input.body;
    }
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  window.fetch = function(input, optionsArgument) {
    let actualUrl;
    let fetchCallArgs;
    let effectiveOptions = {};
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (typeof input === 'string') {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleStringInput(input, optionsArgument));
    } else if (input instanceof Request) {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleRequestInput(input, optionsArgument));
    } else {
      return originalFetch.apply(window, [input, optionsArgument]);
    }

    effectiveOptions.method = effectiveOptions.method || 'GET';
    if (!effectiveOptions.headers) {
      effectiveOptions.headers = new Headers();
    }


    if (typeof actualUrl === 'string' && googleLlmBaseApiUrls.some((url) => actualUrl.startsWith(url))) {
      let apiKeyIsNull = true;

      const regex = new RegExp("models/([^:]+)");
      const modelNameMatch = actualUrl.match(regex);
      const modelName = modelNameMatch ? modelNameMatch[1] : 'unspecified';


      try {
        const urlObject = new URL(actualUrl);  // Use URL object for robust parsing
        const apiKeyParam = urlObject.searchParams.get('key');
        if (apiKeyParam) {
          apiKeyIsNull = false;
        }
      } catch (e) {
        // Continue checks even if URL parsing fails
      }

      if (apiKeyIsNull && effectiveOptions.headers) {
        const h = new Headers(effectiveOptions.headers);
        const apiKeyHeaderValue = h.get('X-API-Key') || h.get('x-api-key');
        if (apiKeyHeaderValue) {
          apiKeyIsNull = false;
          return originalFetch.apply(window, fetchCallArgs);
        }
      }

      if (apiKeyIsNull && effectiveOptions.method && ['POST', 'PUT', 'PATCH'].includes(effectiveOptions.method.toUpperCase()) && typeof bodyForApiKeyCheck === 'string') {
        try {
          const bodyData = JSON.parse(bodyForApiKeyCheck);
          if (bodyData && bodyData.apiKey) {
            apiKeyIsNull = false;
            return originalFetch.apply(window, fetchCallArgs);
          }
        } catch (e) {
          // Ignore JSON parsing errors
        }
      }

      if(apiKeyIsNull) {
        const promiseId = nextPromiseId++;
        const promise = new Promise((resolve) => {
          pendingFetchResolvers[promiseId] = (resolvedResponse) => {
            delete pendingFetchResolvers[promiseId];
            resolve(resolvedResponse);
          };
        });

        let serializedBodyForPostMessage;
        if (typeof bodyForPostMessage === 'string' || bodyForPostMessage == null) {
            serializedBodyForPostMessage = bodyForPostMessage;
        } else if (bodyForPostMessage instanceof ReadableStream) {
            serializedBodyForPostMessage = null;
        } else {
            try {
                serializedBodyForPostMessage = JSON.stringify(bodyForPostMessage);
            } catch (e) {
                serializedBodyForPostMessage = null;
            }
        }

        const messageOptions = {
            method: effectiveOptions.method,
            headers: Object.fromEntries(new Headers(effectiveOptions.headers).entries()),
            body: serializedBodyForPostMessage
        };

        window.parent.postMessage({
          type: 'requestFetch',
          url: actualUrl,
          modelName: modelName,
          options: messageOptions,
          promiseId: promiseId,
        }, '*');

        return promise;
      }
      return originalFetch.apply(window, fetchCallArgs);
    }
    return originalFetch.apply(window, fetchCallArgs);
  };

  window.addEventListener('message', function(event) {
    if (event.data && event.data.type === 'resolveFetch') {
      const { promiseId, response } = event.data;
      if (pendingFetchResolvers[promiseId]) {
        try {
          const reconstructedResponse = new Response(response.body, {
            status: response.status,
            statusText: response.statusText,
            headers: new Headers(response.headers),
          });
          pendingFetchResolvers[promiseId](reconstructedResponse);
        } catch (error) {
          pendingFetchResolvers[promiseId](new Response(null, { status: 500, statusText: "Interceptor Response Reconstruction Error" }));
        }
      }
    }
  });

}))({"textModelName":"gemini-2.5-flash","imageModelName":"imagen-4.0-generate-001","imageEditModelName":"gemini-2.5-flash-image-preview","imageTransformModelName":"gemini-3-pro-image-preview-11-2025","videoModelName":"veo-2.0-generate-001","ttsModelName":"gemini-2.5-flash-preview-tts","deprecatedTextModelNames":["gemini-2.0-flash","gemini-2.5-flash-preview-04-17","gemini-2.5-flash-preview-05-20","gemini-2.5-flash-preview-09-2025"],"deprecatedImageModelNames":["imagen-3.0-generate-001","imagen-3.0-generate-002"]})</script><script>(function(){'use strict';function a(){window.parent.postMessage({type:"interaction"},"*")}window.addEventListener("click",a,{capture:!0,passive:!0});window.addEventListener("touchstart",a,{capture:!0,passive:!0});window.addEventListener("keydown",a,{capture:!0,passive:!0});}).call(this);
</script><script>(function() {
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;

    /**
   * Normalizes an error event or a promise rejection reason into a structured error object.
   * @param {*} errorEventOrReason The error object or reason.
   * @return {object} Structured error data { message, name, stack }.
   */
  function getErrorObject(errorEventOrReason) {
    if (errorEventOrReason instanceof Error) {
      return {
        message: errorEventOrReason.message,
        name: errorEventOrReason.name,
        stack: errorEventOrReason.stack,
      };
    }
    // Fallback for non-Error objects.
    try {
      return {
        message: JSON.stringify(errorEventOrReason),
        name: 'UnknownErrorType',
        stack: null,
      };
    } catch (e) {
      return {
        message: String(errorEventOrReason),
        name: 'UnknownErrorTypeNonStringifiable',
        stack: null,
      };
    }
  }

  /**
   * Converts an array of arguments (from log/error) into a single string.
   * Handles Error objects specially to include their message and stack.
   * @param {Array<*>} args - Arguments passed to console methods.
   * @return {string} A string representation of the arguments.
   */
  function stringifyArgs(args) {
    return args
      .map((arg) => {
        if (arg instanceof Error) {
          const {message, stack} = arg;
          return `Error: ${message}${stack ? ('\nStack: ' + stack) : ''}`;
        }
        if (typeof arg === 'object' && arg !== null) {
          try {
            return JSON.stringify(arg);
          } catch (error) {
            return '[Circular Object]';
          }
        } else {
          return String(arg);
        }
      })
      .join(' ');
  }

  console.log = function(...args) {
    const logString = stringifyArgs(args);
    window.parent.postMessage({ type: 'log', message: logString }, '*');
    originalConsoleLog.apply(console, args);
  };

  console.error = function(...args) {
    let errorData;
    if (args.length > 0 && args[0] instanceof Error) {
      const err = args[0];
      // If the first arg is an Error, capture its details.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        ...getErrorObject(err),
        rawArgsString: stringifyArgs(args.slice(1)),
        timestamp: new Date().toISOString(),
      };
    } else {
      // If not an Error object, treat all args as a general error message.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        message: stringifyArgs(args),
        name: 'ConsoleLoggedError',
        stack: null,
        timestamp: new Date().toISOString(),
      };
    }
    window.parent.postMessage(errorData, '*');
    originalConsoleError.apply(console, args);
  };

  // Listen for global unhandled synchronous errors.
  window.addEventListener('error', function(event) {
    const errorDetails = event.error ? getErrorObject(event.error) : {
      message: event.message,
      name: 'GlobalError',
      stack: null,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
    };

    window.parent.postMessage({
      type: 'error',
      source: 'global',
      ...errorDetails,
      message: errorDetails.message || event.message,
      timestamp: new Date().toISOString(),
    }, '*');
  });

  // Listen for unhandled promise rejections (asynchronous errors).
  window.addEventListener('unhandledrejection', function(event) {
    const errorDetails = getErrorObject(event.reason);

    window.parent.postMessage({
      type: 'error',
      source: 'unhandledrejection',
      ...errorDetails,
      message: errorDetails.message || 'Unhandled Promise Rejection',
      timestamp: new Date().toISOString(),
    }, '*');
  });

})();</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kawaii Pudding Kitchen üçÆ‚ú®</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cherry+Bomb+One&family=Inter:wght@400;600;800&display=swap');
        
        .font-kawaii {
            font-family: 'Cherry Bomb One', cursive;
        }
        
        /* Custom pastel colors */
        .bg-pastel-pink { background-color: #FDDDE6; }
        .text-dark-pink { color: #D53F8C; }
        .border-mint { border-color: #68D391; }
        .bg-mint-light { background-color: #B2F5EA; }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #D53F8C;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Styling for the selection buttons */
        .selection-button {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }
        .selection-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.05);
        }
        .selected-button {
            border: 4px solid #D53F8C; /* Darker Pink Border */
            background-color: #F6E0EE; /* Lighter selection background */
            transform: scale(1.05);
            z-index: 10;
        }
        /* Style for the recipe list scrolling */
        #recipe-list::-webkit-scrollbar {
            width: 8px;
        }
        #recipe-list::-webkit-scrollbar-thumb {
            background-color: #D53F8C;
            border-radius: 4px;
        }
        #recipe-list::-webkit-scrollbar-track {
            background: #FDDDE6;
        }
        
        /* Make the title interactive */
        #main-title {
            cursor: pointer;
            user-select: none;
        }
        /* Style for the dedicated notification banner */
        #notification-banner {
            z-index: 50;
        }
        .permanent-banner {
            background-color: #880E4F; /* Darker Pink for permanent visibility */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body class="bg-mint-light p-4 min-h-screen flex flex-col items-center">
    
    <!-- Dedicated Notification Banner -->
    <div id="notification-banner" class="fixed top-0 left-0 right-0 p-3 text-center text-sm font-kawaii text-white bg-pink-500 shadow-xl transition-all duration-300 transform -translate-y-full opacity-0">
        <!-- Message will be inserted here -->
    </div>

    <div id="app" class="w-full max-w-lg bg-white rounded-3xl p-6 shadow-2xl border-4 border-dark-pink transform transition-all duration-300">
        
        <!-- Secret Unlock Target -->
        <h1 id="main-title" class="text-4xl font-kawaii text-dark-pink text-center mb-6">Pudding Party! ü•≥</h1>

        <!-- 1. Recipe Book (Interactive Feature) -->
        <!-- Initially Hidden by JavaScript -->
        <div id="recipe-book-container" class="mb-6 p-4 bg-pastel-pink rounded-xl shadow-2xl border-4 border-dark-pink hidden">
            
            <div id="recipe-book-header" class="text-xl font-kawaii text-dark-pink text-center py-2">
                üìï Secret Recipe Book Unlocked! üóùÔ∏è
            </div>
            
            <div id="recipe-content" class="mt-4">
                <div id="recipe-list" class="grid grid-cols-2 gap-2 max-h-56 overflow-y-auto p-1">
                    <!-- Recipe Buttons will go here -->
                </div>
                <div id="recipe-details" class="mt-4 p-3 bg-white rounded-lg border-2 border-dark-pink shadow-inner min-h-[4rem]">
                    <p class="text-center font-inter text-sm text-gray-500" id="details-placeholder">Select a recipe to view the ingredients and set the dessert style! ‚ú®</p>
                </div>
            </div>
        </div>

        <!-- Ingredient Selection Area -->
        <div class="space-y-6">

            <!-- Base Ingredients -->
            <div id="base-section">
                <h3 class="text-xl font-kawaii text-gray-800 mb-3 p-2 bg-yellow-100 rounded-lg">1. Choose Your Base ü•£</h3>
                <div class="grid grid-cols-2 gap-3" id="base-options"></div>
            </div>

            <!-- Flavor -->
            <div id="flavor-section">
                <h3 class="text-xl font-kawaii text-gray-800 mb-3 p-2 bg-green-100 rounded-lg">2. Pick Your Flavor üçì</h3>
                <div class="grid grid-cols-2 gap-3" id="flavor-options"></div>
            </div>

            <!-- Toppings -->
            <div id="topping-section">
                <h3 class="text-xl font-kawaii text-gray-800 mb-3 p-2 bg-blue-100 rounded-lg">3. Add Toppings! üçí</h3>
                <div class="grid grid-cols-2 gap-3" id="topping-options"></div>
            </div>

            <!-- Bake Button -->
            <button onclick="bakePudding()" id="bake-button" class="w-full py-4 text-xl font-kawaii text-white bg-dark-pink rounded-2xl shadow-lg hover:bg-pink-600 transition duration-150 selection-button mt-6 flex items-center justify-center space-x-2">
                <span id="button-text">BAKE MY PUDDING! üë©‚Äçüç≥</span>
                <div id="loading-indicator" class="hidden loading-spinner"></div>
            </button>
        </div>
        
        <!-- Result Area -->
        <div id="result-area" class="mt-8 pt-4 border-t-2 border-dashed border-dark-pink">
            <h2 class="text-3xl font-kawaii text-dark-pink text-center mb-4">Your AI-Generated Creation! üíñ</h2>
            <div id="pudding-display" class="w-full h-80 bg-gray-100 rounded-xl shadow-inner flex items-center justify-center overflow-hidden">
                <img id="pudding-image" class="hidden object-cover w-full h-full" alt="AI Generated Dessert">
                <p id="pudding-placeholder" class="text-center text-gray-500 p-4 font-inter">Select your ingredients and press 'BAKE' to generate your custom photo!</p>
            </div>
            <p id="result-text" class="text-center text-lg mt-3 font-kawaii text-gray-700"></p>
        </div>

    </div>

    <script type="module">
        // --- Game Data: Styles ---
        const STYLE_OPTIONS = [
            { name: 'Creamy Pudding', emoji: 'üçÆ', description: 'A smooth, baked or chilled dessert, served in a small ramekin.' },
            { name: 'Shining Gelee Parfait', emoji: 'üåà', description: 'A layered, colorful dessert, served tall in a parfait glass.' }
        ];

        // --- Game Data: Initial Ingredients ---
        const INGREDIENTS_INITIAL = {
            base: [
                { name: 'Classic Milk', emoji: 'ü•õ' },
                { name: 'Vegan Almond', emoji: 'üå∞' },
                { name: 'Coconut Cream', emoji: 'ü••' },
                { name: 'Rich Custard', emoji: 'ü•ö' },
                { name: 'Japanese Tofu', emoji: 'üå±' },
                { name: 'Matcha Green Tea', emoji: 'üçµ' },
                { name: 'Chocolate Mousse', emoji: 'üç´' },
                { name: 'Lavender Infused', emoji: 'üå∏' },
                { name: 'Sweet Potato', emoji: 'üç†' },
                { name: 'Rainbow Swirl', emoji: 'üåà' },
            ],
            flavor: [
                { name: 'Strawberry', emoji: 'üçì' },
                { name: 'Mango Passion', emoji: 'ü•≠' },
                { name: 'Bubblegum', emoji: 'üç¨' }, // <-- THE SECRET TARGET
                { name: 'Blueberry Cheesecake', emoji: 'ü´ê' },
                { name: 'Caramel Salted', emoji: 'üçØ' },
                { name: 'Lemon Zest', emoji: 'üçã' },
                { name: 'Pistachio Dream', emoji: 'üíö' },
                { name: 'Rosewater', emoji: 'üåπ' },
                { name: 'Mint Chip', emoji: 'üçÉ' },
                { name: 'Ginger Spice', emoji: 'üå∂Ô∏è' },
            ],
            topping: [
                { name: 'Mini Marshmallows', emoji: '‚òÅÔ∏è' },
                { name: 'Sparkly Edible Glitter', emoji: '‚ú®' },
                { name: 'Teddy Grahams', emoji: 'üêª' },
                { name: 'Whipped Cream Cloud', emoji: '‚òÅÔ∏è' },
                { name: 'Gold Leaf Flakes', emoji: 'üí∞' },
                { name: 'Crushed Oreos', emoji: '‚ö´' },
                { name: 'Jelly Beans', emoji: 'üü£' },
                { name: 'Mochi Balls', emoji: 'üç°' },
                { name: 'Chocolate Syrup Drizzle', emoji: 'ü§é' },
                { name: 'Candied Violets', emoji: 'üíú' },
                { name: 'Sweet Blueberries', emoji: 'ü´ê' }, // <-- Updated Fruit Topping
            ],
        };

        // --- Game Data: Initial Recipes ---
        const RECIPES_INITIAL = [
            // PUDDINGS (10)
            { name: "Strawberry Delight", emoji: "üçì‚òÅÔ∏è", style: "Creamy Pudding", description: "A classic, comforting blend of creamy milk and sweet berries. Perfect for beginners!", base: "Classic Milk", flavor: "Strawberry", topping: "Whipped Cream Cloud" },
            { name: "Salty Bear Hug", emoji: "üçØüêª", style: "Creamy Pudding", description: "Sweet and salty caramel perfection with a crunchy teddy bear surprise.", base: "Rich Custard", flavor: "Caramel Salted", topping: "Teddy Grahams" },
            { name: "Granny's Secret", emoji: "üç†üå∂Ô∏è", style: "Creamy Pudding", description: "A warm, homey recipe with the subtle sweetness of potato and a spicy kick.", base: "Sweet Potato", flavor: "Ginger Spice", topping: "Mini Marshmallows" },
            { name: "Midnight Bloom", emoji: "üç´üå∏", style: "Creamy Pudding", description: "Dark chocolate mousse paired with a sophisticated, floral aroma.", base: "Chocolate Mousse", flavor: "Rosewater", topping: "Candied Violets" },
            { name: "Citrus Bomb", emoji: "ü•öüçã", style: "Creamy Pudding", description: "Zesty lemon flavor on a creamy custard base, finished with fun, chewy jelly beans.", base: "Rich Custard", flavor: "Lemon Zest", topping: "Jelly Beans" },
            { name: "Spiced Latte Dream", emoji: "‚òïü§é", style: "Creamy Pudding", description: "Rich milk base infused with warm spices and a sweet drizzle.", base: "Classic Milk", flavor: "Ginger Spice", topping: "Chocolate Syrup Drizzle" },
            { name: "Earth's Delight", emoji: "üå±üç°", style: "Creamy Pudding", description: "A grounded, nutty pudding with delightful chewy mochi texture.", base: "Sweet Potato", flavor: "Pistachio Dream", topping: "Mochi Balls" },
            { name: "Tropical Chocolate", emoji: "ü••‚ö´", style: "Creamy Pudding", description: "Exotic mango and coconut mixed with a crunchy chocolate topping.", base: "Coconut Cream", flavor: "Mango Passion", topping: "Crushed Oreos" },
            { name: "Birthday Cake", emoji: "üéÇüç¨", style: "Creamy Pudding", description: "All the fun of a birthday cake in a creamy, bubblegum-flavored cup.", base: "Rich Custard", flavor: "Bubblegum", topping: "Mini Marshmallows" },
            { name: "Caramel Cloud", emoji: "üçØ‚òÅÔ∏è", style: "Creamy Pudding", description: "Smooth caramel on a milky base, topped with light, airy cream.", base: "Classic Milk", flavor: "Caramel Salted", topping: "Whipped Cream Cloud" },
            // GELEE PARFAITS (10)
            { name: "Tropical Sunset", emoji: "ü••ü•≠", style: "Shining Gelee Parfait", description: "Exotic mango passion flavor resting on a light coconut base, kissed with luxury.", base: "Coconut Cream", flavor: "Mango Passion", topping: "Gold Leaf Flakes" },
            { name: "Unicorn Sparkle", emoji: "üåàüç¨", style: "Shining Gelee Parfait", description: "Magic in a tall glass! A shimmering, whimsical parfait that tastes like a dream.", base: "Rainbow Swirl", flavor: "Bubblegum", topping: "Sparkly Edible Glitter" },
            { name: "Night Sky Zen", emoji: "üçµüç°", style: "Shining Gelee Parfait", description: "Earthy matcha flavor balanced with delicate, chewy mochi for a Japanese twist.", base: "Matcha Green Tea", flavor: "Pistachio Dream", topping: "Mochi Balls" },
            { name: "Forest Floor", emoji: "üå±ü´ê", style: "Shining Gelee Parfait", description: "A vegan, refreshing forest fruit medley with rich, dark chocolate notes.", base: "Japanese Tofu", flavor: "Blueberry Cheesecake", topping: "Crushed Oreos" },
            { name: "Minty Comet", emoji: "üå∞üçÉ", style: "Shining Gelee Parfait", description: "A cool, refreshing burst of mint combined with nutty almond goodness.", base: "Vegan Almond", flavor: "Mint Chip", topping: "Chocolate Syrup Drizzle" },
            { name: "Galaxy Jelly", emoji: "üåå‚ú®", style: "Shining Gelee Parfait", description: "A multi-colored, fruit-forward gelee that shimmers like the night sky.", base: "Rainbow Swirl", flavor: "Blueberry Cheesecake", topping: "Sparkly Edible Glitter" },
            { name: "Royal Rose", emoji: "üå∏üí∞", style: "Shining Gelee Parfait", description: "Elegantly flavored with lavender and rose, and finished with a touch of gold.", base: "Lavender Infused", flavor: "Rosewater", topping: "Gold Leaf Flakes" },
            { name: "Vegan Vitamin C", emoji: "üå∞üçã", style: "Shining Gelee Parfait", description: "Bright and zesty lemon gelee on a healthy almond base, decorated with florals.", base: "Vegan Almond", flavor: "Lemon Zest", topping: "Candied Violets" },
            { name: "Midnight Mint", emoji: "üç´üçÉ", style: "Shining Gelee Parfait", description: "A dark, rich chocolate base with a cool mint layer and a dollop of cream.", base: "Chocolate Mousse", flavor: "Mint Chip", topping: "Whipped Cream Cloud" },
            { name: "Berry Tofu", emoji: "üå±üçì", style: "Shining Gelee Parfait", description: "A light, healthy tofu base layered with sweet strawberry flavor and candy treats.", base: "Japanese Tofu", flavor: "Strawberry", topping: "Jelly Beans" },
        ];
        
        // --- Game Data: Great Grandma Pudding Secret Items (GGP) ---
        const INGREDIENTS_SECRET_GRANDMA = {
            base: [
                { name: 'Oatmeal Porridge (GGP)', emoji: 'üåæ' },
                { name: 'Root Beer Float (GGP)', emoji: 'üç∫' },
                { name: 'Black Sesame (GGP)', emoji: '‚ö´' },
                { name: 'Blue Cornmeal (GGP)', emoji: 'üîµ' },
                { name: 'Gingerbread (GGP)', emoji: 'ü´ö' },
            ],
            flavor: [
                { name: 'Pecan Pie (GGP)', emoji: 'ü•ß' },
                { name: 'Cranberry Sauce (GGP)', emoji: 'üî¥' },
                { name: 'Anise Seed (GGP)', emoji: 'üåø' },
                { name: 'Cinnamon Roll (GGP)', emoji: 'ü•®' },
                { name: 'Maple Syrup (GGP)', emoji: 'üçÅ' },
            ],
            topping: [
                { name: 'Candied Bacon Bits (GGP)', emoji: 'ü•ì' },
                { name: 'Dried Apricots (GGP)', emoji: 'üçä' },
                { name: 'Mashed Banana (GGP)', emoji: 'üçå' },
                { name: 'Popcorn (GGP)', emoji: 'üçø' },
                { name: 'Fried Onions (Sweet) (GGP)', emoji: 'üßÖ' },
            ],
        };

        // --- Game Data: Great Grandma Secret Recipes (GGP) (5) ---
        const RECIPES_SECRET_GRANDMA = [
            { name: "Root Beer Float Dream (GGP)", emoji: "üç∫üçø", style: "Creamy Pudding", description: "A nostalgic float flavor made creamy, topped with crunchy popcorn.", base: "Root Beer Float (GGP)", flavor: "Maple Syrup (GGP)", topping: "Popcorn (GGP)" },
            { name: "Grandma's Breakfast (GGP)", emoji: "üåæü•®", style: "Creamy Pudding", description: "Warm, cozy oatmeal with cinnamon roll spice, finished with sweet fruit.", base: "Oatmeal Porridge (GGP)", flavor: "Cinnamon Roll (GGP)", topping: "Mashed Banana (GGP)" },
            { name: "Winter Holiday Bowl (GGP)", emoji: "ü´öüî¥", style: "Creamy Pudding", description: "Spicy gingerbread and tart cranberry, a perfect festive combination.", base: "Gingerbread (GGP)", flavor: "Cranberry Sauce (GGP)", topping: "Dried Apricots (GGP)" },
            { name: "Savory Star Anise (GGP)", emoji: "‚ö´üåø", style: "Shining Gelee Parfait", description: "Exotic black sesame and licorice spice, balanced with savory sweetness.", base: "Black Sesame (GGP)", flavor: "Anise Seed (GGP)", topping: "Fried Onions (Sweet) (GGP)" },
            { name: "Blue Corn Pie (GGP)", emoji: "üîµü•ß", style: "Shining Gelee Parfait", description: "Nutty cornmeal and pecan pie richness, with a surprisingly savory sprinkle.", base: "Blue Cornmeal (GGP)", flavor: "Pecan Pie (GGP)", topping: "Candied Bacon Bits (GGP)" },
        ];


        // --- Live Game State (Initialized in init()) ---
        let INGREDIENTS;
        let RECIPES;
        let selected;
        let isLoading = false;
        
        // Secret 1: Title Tap
        let isRecipeBookOpen = false;
        let secretClickCount = 0;
        let clickTimer = null;
        
        // Secret 2: Bubblegum Tap
        let bubblegumClickCount = 0;
        let isGrandmaSecretUnlocked = false;
        const SECRET_CLICKS_REQUIRED = 27;

        // --- FIX: Global ID to manage notification timers (prevents temporary timer from hiding permanent banner) ---
        let notificationTimeoutId = null; 

        // API Configuration (Keep apiKey as "" for Canvas environment)
        const apiKey = ""; 
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${apiKey}`;

        // --- DOM Elements ---
        const DOMElements = {
            mainTitle: document.getElementById('main-title'),
            baseOptions: document.getElementById('base-options'),
            flavorOptions: document.getElementById('flavor-options'),
            toppingOptions: document.getElementById('topping-options'),
            bakeButton: document.getElementById('bake-button'),
            buttonText: document.getElementById('button-text'),
            loadingIndicator: document.getElementById('loading-indicator'),
            puddingImage: document.getElementById('pudding-image'),
            puddingPlaceholder: document.getElementById('pudding-placeholder'),
            resultText: document.getElementById('result-text'),
            puddingDisplay: document.getElementById('pudding-display'),
            recipeBookContainer: document.getElementById('recipe-book-container'),
            recipeContent: document.getElementById('recipe-content'),
            recipeList: document.getElementById('recipe-list'),
            recipeDetails: document.getElementById('recipe-details'),
            detailsPlaceholder: document.getElementById('details-placeholder'),
            notificationBanner: document.getElementById('notification-banner'),
        };

        /**
         * Helper function to display temporary or permanent messages using the dedicated banner.
         * @param {string} message - The message to display.
         * @param {number} duration - How long to display the message in milliseconds (ignored if permanent is true).
         * @param {boolean} permanent - If true, the banner stays until refresh.
         */
        function showSecretNotification(message, duration = 1000, permanent = false) {
            DOMElements.notificationBanner.textContent = message;
            
            // 1. FIX: Clear any pending hide operation from previous temporary calls
            if (notificationTimeoutId) {
                clearTimeout(notificationTimeoutId);
                notificationTimeoutId = null;
            }

            // 2. Show the banner (reset position)
            DOMElements.notificationBanner.classList.remove('-translate-y-full', 'opacity-0');
            DOMElements.notificationBanner.classList.add('translate-y-0', 'opacity-100');

            if (permanent) {
                // 3a. PERMANENT: Apply dark style, do NOT set a timeout.
                DOMElements.notificationBanner.classList.add('bg-pink-700', 'permanent-banner');
            } else {
                // 3b. TEMPORARY: Ensure permanent style is removed, set timeout to hide.
                DOMElements.notificationBanner.classList.remove('bg-pink-700', 'permanent-banner');
                
                notificationTimeoutId = setTimeout(() => {
                    DOMElements.notificationBanner.classList.remove('translate-y-0', 'opacity-100');
                    DOMElements.notificationBanner.classList.add('-translate-y-full', 'opacity-0');
                    notificationTimeoutId = null; // Clear ID after execution
                }, duration);
            }
        }

        /**
         * Logic to merge new ingredients and recipes into the game state.
         */
        function unlockGrandmaSecret() {
            if (isGrandmaSecretUnlocked) return;

            // 1. Merge the secret items into the main active lists
            INGREDIENTS.base.push(...INGREDIENTS_SECRET_GRANDMA.base);
            INGREDIENTS.flavor.push(...INGREDIENTS_SECRET_GRANDMA.flavor);
            INGREDIENTS.topping.push(...INGREDIENTS_SECRET_GRANDMA.topping);
            RECIPES.push(...RECIPES_SECRET_GRANDMA);
            isGrandmaSecretUnlocked = true;
            
            // 2. Re-render all sections to show new options
            renderOptions('base');
            renderOptions('flavor');
            renderOptions('topping');
            renderRecipes();
            
            // 3. Notify the player using the dedicated banner permanently
            // Duration is ignored, but we pass 'true' for permanent.
            showSecretNotification("üëë GREAT GRANDMA PUDDING'S SECRETS UNLOCKED! üëµüçÆ (GGP) items and recipes are ready! üéâ", 0, true);
        }


        /**
         * Toggles the visibility of the recipe book content (Title Tap Secret).
         */
        function toggleRecipeBook(forceOpen = false) {
            if (forceOpen) {
                isRecipeBookOpen = true;
            } else {
                 isRecipeBookOpen = !isRecipeBookOpen;
            }
            
            // Toggle visibility of the whole container
            DOMElements.recipeBookContainer.classList.toggle('hidden', !isRecipeBookOpen);
            
            // Adjust ingredient numbering based on whether the book is visible
            document.querySelector('#base-section h3').textContent = isRecipeBookOpen 
                ? '2. Choose Your Base ü•£' 
                : '1. Choose Your Base ü•£';
            document.querySelector('#flavor-section h3').textContent = isRecipeBookOpen 
                ? '3. Pick Your Flavor üçì' 
                : '2. Pick Your Flavor üçì';
            document.querySelector('#topping-section h3').textContent = isRecipeBookOpen 
                ? '4. Add Toppings! üçí' 
                : '3. Add Toppings! üçí';
        }

        /**
         * Secret Click Handler for the main title.
         */
        function handleSecretClick() {
            const TITLE_CLICKS_REQUIRED = 5;
            const RESET_TIME_MS = 1000; // Reset counter after 1 second of inactivity

            if (isRecipeBookOpen) {
                // If it's already open, clicking closes it
                toggleRecipeBook(false);
                secretClickCount = 0;
                clearTimeout(clickTimer);
                return;
            }

            // Reset timer on every click
            clearTimeout(clickTimer);
            clickTimer = setTimeout(() => {
                secretClickCount = 0;
            }, RESET_TIME_MS);

            secretClickCount++;

            if (secretClickCount >= TITLE_CLICKS_REQUIRED) {
                toggleRecipeBook(true); // Force open the book
                secretClickCount = 0;
                clearTimeout(clickTimer);
            }
        }

        /**
         * Renders the ingredient buttons for a given category.
         * @param {string} category - 'base', 'flavor', or 'topping'.
         */
        function renderOptions(category) {
            const container = DOMElements[`${category}Options`];
            const data = INGREDIENTS[category];
            
            // Clear existing buttons
            container.innerHTML = '';

            data.forEach(item => {
                const isSelected = selected[category].name === item.name;
                const button = document.createElement('button');
                button.innerHTML = `<span class="text-xl">${item.emoji}</span> ${item.name}`;
                button.className = `
                    w-full p-2 rounded-xl text-sm font-inter font-semibold border-2 border-gray-300 
                    bg-gray-50 text-gray-800 transition duration-150 selection-button
                    ${isSelected ? 'selected-button' : 'hover:bg-gray-100'}
                `;
                button.onclick = () => selectItem(category, item);
                container.appendChild(button);
            });
        }

        /**
         * Renders the clickable recipe list.
         */
        function renderRecipes() {
            DOMElements.recipeList.innerHTML = '';
            RECIPES.forEach(recipe => {
                const button = document.createElement('button');
                button.innerHTML = `${recipe.emoji} ${recipe.name}`;
                button.className = `
                    w-full p-2 rounded-lg text-xs font-inter font-semibold border border-gray-300 
                    bg-white text-gray-800 transition duration-150 hover:bg-yellow-50 shadow-sm
                `;
                button.onclick = () => loadRecipe(recipe);
                DOMElements.recipeList.appendChild(button);
            });
        }

        /**
         * Loads and selects the ingredients for a chosen recipe.
         * @param {Object} recipe - The recipe object.
         */
        function loadRecipe(recipe) {
            if (isLoading) return;

            // 1. Find the actual ingredient objects based on name
            const newStyle = STYLE_OPTIONS.find(s => s.name === recipe.style);
            const newBase = INGREDIENTS.base.find(i => i.name === recipe.base);
            const newFlavor = INGREDIENTS.flavor.find(i => i.name === recipe.flavor);
            const newTopping = INGREDIENTS.topping.find(i => i.name === recipe.topping);

            // 2. Update state and button text (Style change logic moved here)
            if (newStyle) {
                selected.style = newStyle;
                // Update button text based on style directly
                DOMElements.buttonText.textContent = selected.style.name.includes('Pudding') 
                    ? 'BAKE MY PUDDING! üë©‚Äçüç≥' 
                    : 'JELLIFY MY PARFAIT! ü•Ñ';
            }

            if (newBase) selected.base = newBase;
            if (newFlavor) selected.flavor = newFlavor;
            if (newTopping) selected.topping = newTopping;
            
            // 3. Update main selection UI
            renderOptions('base');
            renderOptions('flavor');
            renderOptions('topping');

            // 4. Update recipe details view
            DOMElements.recipeDetails.innerHTML = `
                <h4 class="text-lg font-kawaii text-dark-pink text-center mb-2">${recipe.emoji} ${recipe.name} ${recipe.emoji}</h4>
                <p class="text-sm font-inter text-gray-700 mb-2 text-center italic">${recipe.description}</p>
                <div class="text-xs font-inter text-gray-600 space-y-1">
                    <p>üç∞ Style: <span class="font-bold">${newStyle.emoji} ${recipe.style}</span></p>
                    <p>ü•£ Base: <span class="font-bold">${newBase.emoji} ${recipe.base}</span></p>
                    <p>üçì Flavor: <span class="font-bold">${newFlavor.emoji} ${recipe.flavor}</span></p>
                    <p>üçí Topping: <span class="font-bold">${newTopping.emoji} ${recipe.topping}</span></p>
                </div>
                <p class="text-center text-xs mt-2 text-dark-pink font-semibold">Ingredients selected! Press the button below! ‚ú®</p>
            `;
            
            DOMElements.detailsPlaceholder.classList.add('hidden');
        }

        /**
         * Updates the state when an ingredient is selected and re-renders the buttons.
         * @param {string} category - 'base', 'flavor', or 'topping'.
         * @param {Object} item - The selected item object.
         */
        function selectItem(category, item) {
            if (isLoading) return;

            // --- SECRET BUBBLEGUM UNLOCK LOGIC (27 clicks) ---
            if (category === 'flavor' && item.name === 'Bubblegum' && !isGrandmaSecretUnlocked) {
                bubblegumClickCount++;
                if (bubblegumClickCount < SECRET_CLICKS_REQUIRED) {
                    // Temporary notification for click count
                    showSecretNotification(`Bubblegum Taps: ${bubblegumClickCount}/${SECRET_CLICKS_REQUIRED} üç¨`, 1000, false);
                } else if (bubblegumClickCount === SECRET_CLICKS_REQUIRED) {
                    unlockGrandmaSecret();
                    bubblegumClickCount = 0; // Reset counter
                    return; // Stop processing selection to avoid image generation right after unlock
                }
            }
            // --- END SECRET UNLOCK LOGIC ---


            selected[category] = item;
            // Re-render all sections to update the selected style
            renderOptions('base');
            renderOptions('flavor');
            renderOptions('topping');
        }

        /**
         * Handles the API call to generate the pudding image.
         */
        window.bakePudding = async function() {
            if (isLoading) return;

            // 1. Setup Loading State
            isLoading = true;
            DOMElements.bakeButton.disabled = true;
            DOMElements.buttonText.textContent = 'Preparing dessert... Please Wait! ‚è≥';
            DOMElements.loadingIndicator.classList.remove('hidden');
            DOMElements.puddingImage.classList.add('hidden');
            DOMElements.puddingPlaceholder.textContent = 'Whipping up something magical... ‚ú®';
            DOMElements.puddingDisplay.style.backgroundColor = '#FFFBEB'; 
            DOMElements.resultText.textContent = '';
            
            // 2. Construct Prompt
            const { style, base, flavor, topping } = selected;
            // Determine prompt specifics based on current style in state
            // Puddings are plated upside down! 
            const styleTerm = style.name.includes('Parfait') 
                ? 'layered gelee parfait in a tall glass' 
                : 'creamy pudding plated upside down on a small ceramic dish'; 

            const prompt = `A super kawaii, hyper-realistic photo of a ${styleTerm}, specifically a ${base.name} base with ${flavor.name} flavor. It is elegantly topped with ${topping.name}. Soft studio lighting, 3D rendering, detailed, simple pale pink background. Focus on the dessert.`;
            
            const payload = { 
                instances: [{ prompt: prompt }], 
                parameters: { "sampleCount": 1 } 
            };

            const maxRetries = 3;
            let retryCount = 0;
            let success = false;
            let imageUrl = null;

            while (retryCount < maxRetries && !success) {
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();

                    if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                        imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                        success = true;
                    } else {
                        throw new Error('Invalid image generation response structure.');
                    }
                } catch (error) {
                    retryCount++;
                    if (retryCount < maxRetries) {
                        const delay = Math.pow(2, retryCount) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        console.error("Failed to generate image after retries:", error);
                    }
                }
            }
            
            // 3. Update Result/UI
            isLoading = false;
            DOMElements.bakeButton.disabled = false;
            
            // Re-update button text based on current style (in case manual selection was done)
            DOMElements.buttonText.textContent = selected.style.name.includes('Pudding') 
                ? 'BAKE MY PUDDING! üë©‚Äçüç≥' 
                : 'JELLIFY MY PARFAIT! ü•Ñ';

            DOMElements.loadingIndicator.classList.add('hidden');
            DOMElements.puddingDisplay.style.backgroundColor = '#FDDDE6'; // Pastel pink result background

            if (imageUrl) {
                DOMElements.puddingImage.src = imageUrl;
                DOMElements.puddingImage.classList.remove('hidden');
                DOMElements.puddingPlaceholder.textContent = ''; // Hide placeholder
                DOMElements.resultText.textContent = `A magnificent ${selected.style.name} with ${flavor.name} flavor and a marvelous ${topping.name} topping! Enjoy! üéâ`;
            } else {
                DOMElements.puddingImage.classList.add('hidden');
                DOMElements.puddingPlaceholder.textContent = 'Oh no! The generator failed to create the image. Try again! üò≠';
                DOMElements.resultText.textContent = `Dessert generation failed. Check console for details. üò¢`;
            }
        }

        // --- Initialization ---
        function init() {
            // Reset state variables on every load to ensure non-persistence
            // This guarantees the secret must be triggered again after refresh.
            INGREDIENTS = JSON.parse(JSON.stringify(INGREDIENTS_INITIAL));
            RECIPES = [...RECIPES_INITIAL];
            
            selected = {
                style: STYLE_OPTIONS[0], 
                base: INGREDIENTS.base[0],
                flavor: INGREDIENTS.flavor[0],
                topping: INGREDIENTS.topping[0],
            };
            
            isGrandmaSecretUnlocked = false;
            bubblegumClickCount = 0;

            // Ensure the banner is hidden and reset on load
            DOMElements.notificationBanner.classList.add('-translate-y-full', 'opacity-0');
            // FIX: Ensure both permanent classes are removed on load
            DOMElements.notificationBanner.classList.remove('bg-pink-700', 'permanent-banner'); 

            // Initially hide the recipe book. 
            DOMElements.recipeBookContainer.classList.add('hidden');
            isRecipeBookOpen = false;
            
            // Attach secret click listener to the main title
            DOMElements.mainTitle.addEventListener('click', handleSecretClick);
            
            renderOptions('base');
            renderOptions('flavor');
            renderOptions('topping');
            renderRecipes();
            
            // Ensure the initial button text and numbering is correct
            DOMElements.buttonText.textContent = selected.style.name.includes('Pudding') 
                ? 'BAKE MY PUDDING! üë©‚Äçüç≥' 
                : 'JELLIFY MY PARFAIT! ü•Ñ';
                
            document.querySelector('#base-section h3').textContent = '1. Choose Your Base ü•£'; 
            document.querySelector('#flavor-section h3').textContent = '2. Pick Your Flavor üçì';
            document.querySelector('#topping-section h3').textContent = '3. Add Toppings! üçí';
        }

        window.onload = init;
    </script>

</body></html>